<!DOCTYPE html>
<html lang=RU>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="generator" content="Hexo 3.9.">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62489908-6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-62489908-6');
    </script>

    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Перед тем, как начать изучать командную болочку bash, есть несколько важных концепций, помимо основных команд, необходимых к изучению.  Помимо основ и управления доступом пользователей, необходимо изучить среду.">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Основы командной оболочки Bash">
<meta property="og:url" content="http://zachgoll.github.io/blog/2019/bash-essentials/index.html">
<meta property="og:site_name" content="Зак Голлвитцер">
<meta property="og:description" content="Перед тем, как начать изучать командную болочку bash, есть несколько важных концепций, помимо основных команд, необходимых к изучению.  Помимо основ и управления доступом пользователей, необходимо изучить среду.">
<meta property="og:locale" content="RU">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/vscode-search.png">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/digital-ocean-key.png">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/basic-web-search.jpg">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/ipaddresses.PNG">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/processes-linux.png">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/top-header.png">
<meta property="og:updated_time" content="2019-11-25T15:55:49.362Z">
<meta name="twitter:card" content="Содержание">
<meta name="twitter:title" content="Основы командной оболочки Bash">
<meta name="twitter:description" content="Перед тем, как начать изучать командную болочку bash, есть несколько важных концепций, помимо основных команд, необходимых к изучению.  Помимо основ и управления доступом пользователей, необходимо изучить среду.">
<meta name="twitter:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/vscode-search.png">
    
    
        
          
              <link rel="shortcut icon" href="/blog/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/blog/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Основы командной оболочки Bash</title>
    <!-- styles -->
    <link rel="stylesheet" href="/blog/css/style.css">
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="http://zachgoll.github.io">Домашняя страница</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="http://zachgoll.github.io/portfolio">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/blog/2019/ip-addresses-netmasks/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/blog/2019/user-permissions/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Предыдущий пост</span><span id="i-next" class="info" style="display:none;"> Следующий пост</span><span id="i-top" class="info" style="display:none;"> Вернуться наверх</span><span id="i-share" class="info" style="display:none;"> Поделиться публикацией</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;text=Bash Essentials"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;is_video=false&amp;description=Bash Essentials"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Bash Essentials&amp;body=Check out this article: http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;name=Bash Essentials&amp;description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Environment-variables"><span class="toc-number">1.</span> <span class="toc-text">Переменные среды</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Variables"><span class="toc-number">1.1.</span> <span class="toc-text">Переменные оболочки</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PATH-variable"><span class="toc-number">1.2.</span> <span class="toc-text">Переменная PATH</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Common-Commands"><span class="toc-number">1.3.</span> <span class="toc-text">Общие команды</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">1.3.1.</span> <span class="toc-text">grep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk-and-sed"><span class="toc-number">1.3.2.</span> <span class="toc-text">awk и sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Less"><span class="toc-number">1.3.3.</span> <span class="toc-text">Less</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-and-exec"><span class="toc-number">1.3.4.</span> <span class="toc-text">find и exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar-gzip-gunzip"><span class="toc-number">1.3.5.</span> <span class="toc-text">tar, gzip, gunzip</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Advanced-Bash"><span class="toc-number">2.</span> <span class="toc-text">дополнительные возмодности Баш</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Regular-Expressions"><span class="toc-number">2.1.</span> <span class="toc-text">Обычные выражения</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Detailed-Example-Regular-Expression"><span class="toc-number">2.1.1.</span> <span class="toc-text">Подробный пример регулярных выражений</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-Scripting"><span class="toc-number">2.2.</span> <span class="toc-text">Сценарии Bash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Variable-declarations"><span class="toc-number">2.2.1.</span> <span class="toc-text">Объявления переменных</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Built-In-Variables"><span class="toc-number">2.2.2.</span> <span class="toc-text">Встроенные переменные</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-Line-Arguments"><span class="toc-number">2.2.3.</span> <span class="toc-text">Аргументы командной строки</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reading-user-input"><span class="toc-number">2.2.4.</span> <span class="toc-text">Чтение ввода с клавиатуры</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-loops"><span class="toc-number">2.2.5.</span> <span class="toc-text">циклы for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-then-statements"><span class="toc-number">2.2.6.</span> <span class="toc-text">операторы if-then</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions"><span class="toc-number">2.2.7.</span> <span class="toc-text">Функции</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-Machines-and-SSH-Protocol"><span class="toc-number">2.3.</span> <span class="toc-text">Виртуальные машины и протокол SSH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Permanently-Add-Keys-to-ssh-agent"><span class="toc-number">2.3.1.</span> <span class="toc-text">Permanently Add Keys to ssh-agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-local-computer-to-remote-machine"><span class="toc-number">2.3.2.</span> <span class="toc-text">С локального компьютера на удаленный</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-remote-machine-to-local-computer"><span class="toc-number">2.3.3.</span> <span class="toc-text">С удаленного компьютера на локальный</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Downloading-packages-to-your-remote-machine-with-wget"><span class="toc-number">2.3.4.</span> <span class="toc-text">Загрузка пакетов на удаленный компьютер при помощи wget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-VSCode-with-your-remote-machine"><span class="toc-number">2.3.5.</span> <span class="toc-text">Использование VSCode на удаленной машине</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Networking-on-Command-Line"><span class="toc-number">2.4.</span> <span class="toc-text">Работа в сети в командной строке</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Your-home-network-and-the-internet"><span class="toc-number">2.4.1.</span> <span class="toc-text">Ваша домашняя сеть и Интернет</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifconfig"><span class="toc-number">2.4.2.</span> <span class="toc-text">ifconfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping"><span class="toc-number">2.4.3.</span> <span class="toc-text">ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#traceroute"><span class="toc-number">2.4.4.</span> <span class="toc-text">traceroute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat"><span class="toc-number">2.4.5.</span> <span class="toc-text">netstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dig-host-whois"><span class="toc-number">2.4.6.</span> <span class="toc-text">dig/host/whois</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Process-Management-and-System-Management"><span class="toc-number">2.5.</span><span class="toc-text">Управление процессами и управление системой</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-Process"><span class="toc-number">2.5.1.</span> <span class="toc-text">Что такое процесс?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processes-Behind-the-Scenes"><span class="toc-number">2.5.2.</span> <span class="toc-text">Процессы: что за кулисами</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foreground-vs-Background-Processes"><span class="toc-number">2.5.3.</span> <span class="toc-text">Процессы на переднем плане и фоновые процессы</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ps-and-top-commands-system-performance-management"><span class="toc-number">2.5.4.</span> <span class="toc-text">команды ps и top (управление производительностью системы)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsof"><span class="toc-number">2.5.5.</span> <span class="toc-text">lsof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-time"><span class="toc-number">2.5.6.</span> <span class="toc-text">free, time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">2.6.</span> <span class="toc-text">Заключение</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Основы командной оболочки Bash
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Зак Голлвитцер</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-02-03T21:50:19.000Z" itemprop="datePublished">2019-02-03</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/blog/tags/linux/">linux</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Перед тем, как начать изучать командную болочку bash, есть несколько важных концепций, помимо основных команд, необходимых к изучению. Перед освоением <a href>основ</a> и управления <a href="/blog/2019/user-permissions/">правами пользователя</a> необходимо изучить переменные среды, псевдонимы и некоторые более сложные команды, относящиеся к сетям, управлению процессами, ssh и сценариям.</p>
<h1 id="Environment-variables"><a href="#Environment-variables" class="headerlink" title="Переменные среды"></a>Переменные среды</h1><iframe width="560" height="315" src="https://www.youtube.com/embed/5e-kS5LkByc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Переменная среды может быть глобальной или локальной. Глобальная переменная среды - это переменная, которая устанавливается при инициализации оболочки и может использоваться во всех дочерних скриптах.  Сеансовая (локальная) переменная среды - это переменная, которая устанавливается во время конкретного сеанса оболочки и стирается при его закрытии. Чтобы создать сеансовую переменную среды надо export-ировать ее в текущую оболочку.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MY_VARIABLE=<span class="string">"значение"</span></span><br></pre></td></tr></table></figure>
<p>Ее можно использовать пока оболочка все еще открыта.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span> <span class="comment"># значение</span></span><br></pre></td></tr></table></figure>
<p>Как только вы закроете оболочку, переменная более не будет доступна. Чтобы сделать переменную глобальной, ее помещают в один из файлов конфигурации bash. Рекомендуется поместить ее в <code>~/.profile</code>-файл, как описано в <a href="/blog/2019/user-permissions/">в этом руководстве</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.profile</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GLOBAL_VARIABLE=<span class="string">"значение"</span></span><br></pre></td></tr></table></figure>
<p>Чтобы увидеть все переменные текущего сеанса (как локальные, так и глобальные), можно запустить команду</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure>
<h2 id="Shell-Variables"><a href="#Shell-Variables" class="headerlink" title="Переменные среды"></a>Переменные среды</h2><p>Пользователи bash часто путаются, говоря о переменных <em>среды</em> и переменных <em>оболочки</em>. Независимо от того, является ли переменная среды локальной или глобальной, все сценарии, запущенные в этом сеансе bash, будут иметь доступ к переменной. С переменной оболочки все не так: другие сценарии не будут иметь к ней доступа. Ниже показано, как объявляются переменные оболочки.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MY_SHELL_VARIABLE=<span class="string">"значение"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_SHELL_VARIABLE</span>  <span class="comment"># значение</span></span><br></pre></td></tr></table></figure>
<p>Эта переменная не будет доступна ни одному сценарию, пока не будет экспортирована и не сделана переменной среды.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MY_SHELL_VARIABLE</span><br></pre></td></tr></table></figure>
<h2 id="PATH-variable"><a href="#PATH-variable" class="headerlink" title="Переменная PATH"></a>Переменная PATH</h2><p>Самая важная глобальная переменная среды, которую очень часто устанавливают, - это переменная <code>PATH</code>. Она сообщает оболочке bash, где искать исполняемые файлы и сценарии. Оболочка перебирает каталоги, перечисленные в переменной <code>PATH,</code> пытаясь найти программу, которую требуется запустить. Вот пример установки переменной PATH.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin</span><br></pre></td></tr></table></figure>
<p>В этом примере, если пользователь хочет запустить программу <code>cat</code>, bash сначала будет искать ее в директории <code>/usr/local/bin</code>. Если он не найдет его там, он перейдет в <code>/usr/bin</code>, и, наконец, в <code>/bin</code>. Если вам нужно изменить путь, вы можете обновить его в своем <code>~/.profile</code>: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/zach/script-location:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>Команда добавляет директорий <code>/home/zach/script-location</code> в начало списка <code>PATH</code>. Если вы хотите добавить новый директорий его в конец списка, то это делается следующим образом: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/zach/script</span><br></pre></td></tr></table></figure>
<p>Теперь можно создавать специальные библиотеки сценариев и запускать их автоматически из директориев, указанных в PATH. Теперь создадим каталог в домашней папке, который будет хранить все наши скрипты.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ </span><br><span class="line">mkdir bin </span><br><span class="line">touch bin/my-simple-script</span><br></pre></td></tr></table></figure>
<p>Теперь надо добавить этот текст в <code>my-simple-script</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Я не совсем полезный скрипт, предназначенный исключительно для демонстрации."</span></span><br></pre></td></tr></table></figure>
<p>Теперь устанавливаем флаг, позволяющий запускать скрипт.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 my-simple-script</span><br></pre></td></tr></table></figure>
<p>Тепер надо добавить новый каталог <code>/bin</code> к нашей PATH. Редактируем <code>~/.profile</code> (или другой, где определяется переменная <code>PATH</code>), добавляем следующую строку.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/bin</span><br></pre></td></tr></table></figure>
<p>Наконец, активируем изменения из <code>source ~/.profile</code> в текущем сеансе.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure>
<p>Теперь можно запускать свой скрипт из командной строки, указав его имя.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my-simple-script  </span><br><span class="line"><span class="comment"># Я не совсем полезный скрипт, предназначенный исключительно для демонстрации.</span></span><br></pre></td></tr></table></figure>
<h2 id="Common-Commands"><a href="#Common-Commands" class="headerlink" title="Основные команды"></a>Основные команды</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/yCTnihfbPCo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Помимо основных команд, таких как <code>cd</code>, <code>ls</code>, <code>mkdir</code>, <code>touch</code> и т.д., есть небольшой список команд, которые в bash используются на регулярной основе.</p>
<ul>
<li>grep</li>
<li>awk/sed</li>
<li>less</li>
<li>Команды find и exec</li>
<li>gunzip</li>
<li>tar</li>
</ul>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>Grep - это инструмент, который ищет шаблоны или слова в одном или нескольких файлах. Программа существует в двух версиях: BSD и GNU. В системах Mac используются BSD-вариянт, системы с Linux - GNU. В рассмотренных далее примерах различия между этими версиями не заметны, но если вдруг в той или иной операционной системе что-то пойдет не по плану, надо уточнить свойства конкретной версии. Например, могут отличаться определенные типы регулярных выражений.</p>
<p>Grep можно воспринимать как инструмент поиска, встроенный в командную строку. В современных средах программирования (текстовых редакторах) есть много инструментов поиска. Например, в Visual Studio Code Editor можно использовать строку поиска для того, чтобы искать в файлах проекта определенное слово или даже соответствие регулярному выражению. В результате редактором перечисляются файлы, в которых было найдено выражение, указывается строка, где оно было найдено и т.д.</p>
<img src="/blog/2019/bash-essentials/vscode-search.png">
<p>В этом примере, автор искал в своем блоге слово "grep" и нашел его в трех разных файлах. Но что делать, если VSCode недоступен? Такое может быть, если вы управляете удаленной машины, или, просто, к этой удивительной функции поиска нет доступа? В этом случае grep просто незаменим. Основной синтаксис для использования grep следующий: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [все опции и ключи здесь] <span class="string">"текст, который ищется"</span> &lt;имя-файла-где-ищем&gt;</span><br></pre></td></tr></table></figure>
<p>Например, попробуем найти имя пользователя в файле <code>/etc/passwd</code> (где хранятся все пользователи в системе).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Необходимо использовать sudo, потому что этот файл защищен</span></span><br>&lt;/br2&gt;<span class="line"><span class="comment"># Флаг (ключ) -i переводит поиск в режим игнорирования размера букв </span></span><br><span class="line">sudo grep -i <span class="string">"zach"</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"><span class="comment"># zach:x:1000:1000:Zach,,,:/home/zach:/bin/bash</span></span><br></pre></td></tr></table></figure>
<p>Хотя это руководство не преследует целью детально описать регулярные выражения, все же рассмотрим простой пример. Например, чтобы найти всех пользователей, имена которых состоят из трех символов,  надо исползовать флаг <code>-E</code>, включающий режим “расширенных регулярных выражений”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo grep --color -E <span class="string">"^[a-z]{3}:"</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Результат --- </span></span><br><span class="line"><span class="comment">#bin:x:2:2:bin:/bin:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#sys:x:3:3:sys:/dev:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false</span></span><br></pre></td></tr></table></figure>
<p><code>bin</code>, <code>sys</code>, <code>man</code>, <code>irc</code>, and <code>gdm</code> are all three letter usernames. Если результат выдатся в монохромном режиме, можно его раскрасить, добавив флаг <code>цвета</code>.</p>
<p>Еще один способ использования grep - в режиме фильтра вывода другой команды. Результат (stdout), выдаваемый одной командой, можно передать на вход (stdin) grep. Теперь то, что мы делали выше, можно сделать по-другому: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/passwd | grep --color -E <span class="string">"^[a-z]{3}:"</span></span><br></pre></td></tr></table></figure>
<p>Таким образом, утилита <code>grep</code> полезна для быстрого поиска, если у вас нет доступа к текстовому редактору, например, VSCode, или нет желания ждать, пока он загрузится.</p>
<h3 id="awk-and-sed"><a href="#awk-and-sed" class="headerlink" title="Утилиты awk и sed"></a>Утилиты awk и sed</h3><p>В настоящее время, <code>awk</code> и <code>sed</code> являются предметом споров и обсуждений, и в этом разделе попробуем разъяснить <em>почему</em> это происходит, ну и покажим основные формы их использования. Причина стосторит в том, что сейчас существуют лучшие альтернативы. Обе программы обрабатывают тексты, они могут находить <em>и</em> заменять части одного файла или наборы файлов.  </p>
<p>Программа sed является редактором текстового потока (Stream EDitor): производит посимвольный просмотр файла, и не считается полноценным языком программирования. Он отлично подходит для простых операций типа "найти и заменить" над одним или несколькими файлами. Опять же, эта операция элементарно реализуется в текстовых редакторах типа VSCode, но иногда к реадактору нет доступа, или есть необходимость выполнения операции над группой файлов, в скрипте.</p>
<p>Язык awk считается вычислительно полным языком программирования (полным по Тьюрингу?) и больше ориентирован на табличные текстовые данные, где столбцы разделены специальными символами, например формата CSV (Comma Separated Values). Например, <code>awk</code> хорошо разбивает файл csv или файл, разделенный пробелами, поскольку он обрабатывает вхдоной файл построчно, а не посимвольно.</p>
<p>Проблема с этими программами заключается в том, что все, что можно сделать, комбинируя sed или awk, можно реализовать в языках Perl или Python в более простой. Бесспорно, Perl и Python являются гораздо более удобными языками реализации сценариев. В защиту утилит высказывают, что sed и awk обладают превосходной производительностью на определенных задачах, но практика показывает, что Perl или Python все же лучшие решения.</p>
<p>Однако в некоторых задачах администрирования обрабатывать тексты приходится при помощи sed и awk, так как, опять же, может не быть доступа к Python или Perl.  Теперь возникает вопрос: в чем разница между этими утилитами? Когда надо использовать sed, а когда awk? Вот несколько простых правил: </p>
<ul>
<li>Для простых текстовых преобразований (например, найти/заменить), используйте sed.</li>
<li>Для простых преобразований формата используйте awk</li>
<li>Для сложных преобразований формата и текста используйте awk</li>
</ul>
<p>Рассмотрим примеры каждой из задач, покажем использование обоих инструментов. Начнем с простой операции по поиску/замене при помощи sed. В качестве обрабатываемого текта использован образец файла от Apple Inc., данные по акциям за последние 3 месяца, файл <code>AAPL.csv</code>. Исходные данные: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date,Open,High,Low,Close,Adj Close,Volume</span><br><span class="line">2018-11-06,201.919998,204.720001,201.690002,203.770004,203.061493,31882900</span><br><span class="line">2018-11-07,205.970001,210.059998,204.130005,209.949997,209.219986,33424400</span><br><span class="line">2018-11-08,209.979996,210.119995,206.750000,208.490005,208.490005,25362600</span><br><span class="line"></span><br><span class="line">... пропущены аналогичные записи ...</span><br>&lt;/br11&gt;<span class="line"></span><br><span class="line">2019-02-04,167.410004,171.660004,167.279999,171.250000,171.250000,31495500</span><br><span class="line">2019-02-05,172.860001,175.080002,172.350006,174.179993,174.179993,36066500</span><br></pre></td></tr></table></figure>
<p>Для замены всх запятых с пробелами  удобно исползовать sed.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/,/ /g'</span> AAPL.csv</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date Open High Low Close Adj Close Volume</span><br><span class="line">2018-11-06 201.919998 204.720001 201.690002 203.770004 203.061493 31882900</span><br><span class="line">2018-11-07 205.970001 210.059998 204.130005 209.949997 209.219986 33424400</span><br><span class="line">2018-11-08 209.979996 210.119995 206.750000 208.490005 208.490005 25362600</span><br><span class="line"></span><br><span class="line">... пропущены аналогичные записи ...</span><br>&lt;/br11&gt;<span class="line"></span><br><span class="line">2019-02-04 167.410004 171.660004 167.279999 171.250000 171.250000 31495500</span><br><span class="line">2019-02-05 172.860001 175.080002 172.350006 174.179993 174.179993 36066500</span><br></pre></td></tr></table></figure>
<p>Будет распечатан результат преобразования из sed. Если добавить флаг -i, то sed будет редактировать исходный файл (in-place).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/,/ /g'</span> AAPL.csv</span><br></pre></td></tr></table></figure>
<p>Теперь, когда у нас есть файл, где столбцы разделены пробелами. Теперь можно использовать <code>awk</code> для вычисления агрегированных значений. В этих данных в текущем их состоянии цена акций задается в нескольких столбцах (open, high, low, close, adjusted), что можно подправить. Например, выделим цены в колонках open и volume по датам (date). Для выделения этих столбщов используем awk.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">" "</span> <span class="string">' BEGIN { print "Date\t\tPrice\t\tVolume" }; NR &gt; 1 { print $1 "\t" $2 "\t" $7 } '</span> AAPL.csv</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date            Price           Volume</span><br><span class="line">2018-11-06      201.919998      31882900</span><br><span class="line">2018-11-07      205.970001      33424400</span><br><span class="line">2018-11-08      209.979996      25362600</span><br><span class="line"></span><br><span class="line">... пропущены аналогичные записи ...</span><br>&lt;/br11&gt;<span class="line"></span><br><span class="line">2019-02-04      167.410004      31495500</span><br><span class="line">2019-02-05      172.860001      36066500</span><br></pre></td></tr></table></figure>
<p>На первый взгляд команда выглядит слишком сложной для изучения, но проведем некоторый ее обзор. Основы синтаксиса awk можно узнать, сделав соответствующие запросы к поисковой системе Google, такжк можно найти примеры решения конкретных задач.</p>
<p>Программа awk - это больше язык программирования, а не команда обработки текста. Чтобы узнать, что означает вышеупомяшная команда, сохраним ее в файл, что удобнее для обучения. Создадим файл <code>awk-example.sh</code> и поместим туда вышеупомятую команду, отформатируем текст программы.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Это комментарий в программе awk</span></span><br>&lt;/br2&gt;<span class="line"><span class="comment"># Перед тем, как непосредственно перейти к обработке текста установим переменную FS (задает символ-резделитель колонок), </span></span><br>&lt;/br5&gt;<span class="line"><span class="comment"># переменную OFS (символ-резделитель в выходных данных), и затем распечатаем заголовок текста в порождаемом результате.</span></span><br>&lt;/br8&gt;<span class="line">BEGIN {</span><br><span class="line">        <span class="comment"># Обратите внимание, каждая строка заканчивается символом ";", что приближает этот скрипт к языку программирования C.</span></span><br>&lt;/br13&gt;<span class="line">        FS=<span class="string">" "</span>;</span><br><span class="line">        OFS=<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"Date\t\tPrice\t\tVolume"</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment"># NR &gt; 1 означает, что надо распечатать значения из строк, номера которых больше 1.</span></span><br>&lt;/br30&gt;<span class="line"><span class="comment">#   Другими словами, мы пропускаем первую строку.<br>&lt;/br33&gt;<span class="line">NR &gt; 1 {</span><br><span class="line">        <span class="comment"># Выводим первое, второе и седьмое значение их каждой строки.</span></span><br>&lt;/br38&gt;<span class="line">        <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$7</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>Запуск программы осуществляется так: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Выводится то же самое, что в результате звапуска </span></span><br>&lt;/br2&gt;<span class="line"><span class="comment"># awk -F " " ' BEGIN { print "Date\t\tPrice\t\tVolume" }; NR &gt; 1 { print $1 "\t" $2 "\t" $7 } ' AAPL.csv</span></span><br><span class="line"><span class="comment"># Загружаем программу из awk-example.sh, применяем ее к файлу AAPL.csv.csv</span></span><br>&lt;/br8&gt;<span class="line">awk -f awk-example.sh AAPL.csv</span><br></pre></td></tr></table></figure>
<p>Как можно было заметить, в awk есть встроенные переменные, включая <code>FS</code> (символ-разделитель входного файла), <code>OFS</code> (символ-резделитель для выходного файла), <code>NR</code> (номер строки). Дркгие переменные можно найти <a href="https://www.tutorialspoint.com/awk/awk_built_in_variables.htm" target="_blank" rel="noopener">здесь</a>. Можно использовать переменные вместо задания флагов в командной строке. Например, вместо флага <code>-F " "</code> можно установить соответствующее значение переменной <code>FS</code> в программе awk.</p>
<p>Обучение всем возможностям <code>awk</code> займает гораздо больше времени, чем это оправдано для данного руководства, но освоив основу синтаксиса, проще изучить все остальное. В конечном счете, каждая awk команда есть наборы ключевых слов и команд формирования выходных данных. Команда, которую только что запустили, полностью показана ниже.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk executable  Options   Keyword  What to print based on keyword          Keyword   What to print based on keyword file to run</span></span><br><span class="line">awk               -F <span class="string">" "</span> <span class="string">'  BEGIN    { print "Date\t\tPrice\t\tVolume" };    NR &gt; 1    { print $1 "\t" $2 "\t" $7 } '</span> aapl.csv</span><br></pre></td></tr></table></figure>
<p>Программа awk обладает большим набором функций, включая редактирование файлов. Хороший учебник по программе находится <a href="https://likegeeks.com/awk-command/" target="_blank" rel="noopener">здесь</a>.</p>
<p>На самом деле для более сложных задач нет необходимости в е изучении sed и awk. Языки Perl/Python также позволяют обрабатывать текст, при этом использовать более простой синтаксис. Тем не менее, знание основ использования этих команд может значительно ускорить ваш рабочий процесс при решении простых задач, которые периодически возникают. Они также полезны когда вы пишете сценарий для bash, где нужно как-то редактировать текст или изымать оттуда информацию. Было бы неудобно вручную останавливать сценарий bash, запускать скрипт python, а затем перезапускать сценарий снова. Утилиты sed и awk предоставляют возможность избегать такого варианта обработки информации.</p>
<h3 id="Less"><a href="#Less" class="headerlink" title="Программа Less"></a>Программа Less</h3><p>Программа less одной из тех утилит командной строки, которую вы наверняка не используете, а должны были бы. Программа позволяет просматривать текстовые денные, интерактивно прокручивая строки на экране при помощи клавиатуры. Программа проста в использовании, и работает аналогично редактору vim. Существует два способа использования less: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Передача выходных данных в less из другой программы</span></span><br><span class="line">cat some-large-file.txt | less </span><br><span class="line"></span><br><span class="line"><span class="comment"># Использование less напрямую</span></span><br><span class="line">less some-large-file.txt</span><br></pre></td></tr></table></figure>
<p>В запущенной программе есть замечательная функция - h. Нажатие <code>h</code> открывает панель помощи, где отображаются все возможные интерактивные команды. Приведем самые полезные.</p>
<ul>
<li>Для прокрутки на одну строку, жмите <code>k</code> (как в vim)</li>
<li>Для прокурутки на одну линию вниз, жмите <code>j</code> (как в vim)</li>
<li>Чтобы перейти в конец файла, жмите <code>G</code></li>
<li>Чтобы перейти к началу файла, жмите <code>g</code></li>
<li>Для поиска "текста", наберите <code>/текст</code> (поиск по тексту вниз) или '?</li>
<li>Для продвижения вниз на страницу, жмите <code>f</code> или "пробел"</li>
<li>Чтобы пролистать на страницу вверх, жмите <code>b</code></li>
</ul>
<p>Так же, как grep, awk и sed, прокрутка и поиск в тексте удобнее делть в текстовых редакторах, например, VSCode. Если есть возможность используйте редактор. Использование команды <code>less</code> удобно, если редактор недоступен или медленнее, чем нужно, грузится.</p>
<h3 id="find-and-exec"><a href="#find-and-exec" class="headerlink" title="Команды find и exec"></a>Команды find и exec</h3><p>На первый взгляд, команда find очень сильно похожа на grep, но ее использование охватывает решение других задач. Программа поиска необходима, если вы хотите искать файлы с определенными свойствами во всей файловой системе. Напомним, что grep ищет текст в файле или в текте-результате предыдущей команды, find ищет именно файлы в файловой системе. Почему он полезен? Команда find возвращвет полный путь до файла по имени и или атрибутам: запускаемый, читаемый, редактируемый и т.д. Например, давным-давно вы установили нужную вам версию Python и не можете вспомнить, куда вы скачали архив его исходников. Это обычная проблема - порождать версии Python на вашей машине, которые конфликтуют друг с другом. Кроме того, часто надо полностью удалить все версии Python с компьютера. Другие виды использования find включают: </p>
<ul>
<li>Найти все файлы .png на компьютере</li>
<li>Найти все документы, измененные некоторым пользователем за последние 7 дней</li>
<li>Найти файлы, имеющие определенный набор разрешений (permission set)</li>
</ul>
<p>Как видно, возможности <code>find</code> практически безграничны, и если использовать ее весь потенциал, можно решить много разных задач, включа те, до которых вы раньше не додумывались. Вот простой пример: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -size +1G</span><br></pre></td></tr></table></figure>
<p>Эта команда перечислит все файлы на компьютере, размер которых больше 1 гигабайта. Если у вас мало места на дисках, эта команда поможет найти те файлы, которые занимает недоступное пространство на вашем компьютере.</p>
<p>Основным форматом использования команды find является </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;директорий, где производить поиск&gt; [флаги] &lt;имя файла, который ищем&gt;</span><br></pre></td></tr></table></figure>
<p>Вот несколько полезных и часто используемых команд:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Найти все .jpg-файлы на компьютере</span></span><br><span class="line">find / -<span class="built_in">type</span> f <span class="string">"*.jpg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Найти все файлы, измененные за прошедшие сутки</span></span><br>&lt;/br11&gt;<span class="line">find / -<span class="built_in">type</span> f -mtime 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Найти все файлы, которые принадлежат пользователю zach</span></span><br>&lt;/br19&gt;<span class="line">find / -<span class="built_in">type</span> f -user zach</span><br><span class="line"></span><br><span class="line"><span class="comment"># Найти все файлы с кодом разрешений 777</span></span><br><span class="line">find / -<span class="built_in">type</span> f -perm 777</span><br><span class="line"></span><br><span class="line"><span class="comment"># Найти все файлы, имена которых начинаются со слова config</span></span><br>&lt;/br35&gt;<span class="line">find / -<span class="built_in">type</span> f -name <span class="string">"config*"</span></span><br></pre></td></tr></table></figure>
<p>Это всего лишь несколько из тысячи других функций программы. Кроме того, используя команду <code>exec</code>, <code>find</code> переходит на новый уровень. Вместо того, чтобы просто искать файлs, можно также выполнять с ними другие операции. Хотя это очень здорово, но и очень опасно, если не соблюдать осторожность, ясно представлять, что будет происходить во время исполнения команды. Функция exec позволяет запускать другие команды над найденным <code>find</code> файлом. Если вы объедините <code>find</code> и <code>rm</code>, запущенной при помощи <code>exec</code>, вы можете удалить найденные файлы. Поэтому, прежде чем запускать такие конструкции, проверяйте все десять раз!</p>
<p>Пусть есть простая команда на основе find, которая ищет все файлы .jpg домашнем каталоге.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/ -<span class="built_in">type</span> f -name <span class="string">"*.jpg"</span></span><br></pre></td></tr></table></figure>
<p>Если есть необходимость скопировать все совпадения в папку <code>~/pictures-backup</code>, добавляем команду exec.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/ -<span class="built_in">type</span> f -name <span class="string">"*.jpg"</span> -<span class="built_in">exec</span> <span class="string">'{}'</span> ~/pictures-backup \;</span><br></pre></td></tr></table></figure>
<p>Навеное интересно, что такое <code>'{}'</code> и <code>\;</code>, что это за элементы, использованные в команде. Пользуясь новыми навыками, вы можете посмотреть дополнительную информацию о <code>exec</code>, перенаправив вывод-страницу man в less и выполнив поиск по слову «exec».</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man find | less </span><br><span class="line">/-<span class="built_in">exec</span></span><br><span class="line">п<span class="comment"> # повторяет поиск для строки -exec и находит следующее его вхождение</span></span><br></pre></td></tr></table></figure>
<p>На этих страницах руководства видно, что <code>'{}'</code> указывает место, куда подставлять найденные файлы, и <code>\;</code> - это символ, указывающий грннацу команды для запуска <code>exec</code>. Обратная косая черта - это механизм "избавления от лишних проблем". Можно просто использовать <code>';'</code>.  </p>
<p>После выполнения этой команды, все изображения jpg из домашнего каталога будут скопированы в централизованное хранилище резервных копий! Теперь вы видете, как крута эта команда!</p>
<h3 id="tar-gzip-gunzip"><a href="#tar-gzip-gunzip" class="headerlink" title="Команды tar, gzip, gunzip"></a>Команды tar, gzip, gunzip</h3><p>Эти утилиты не имеют какого-то сложного набора функций и используются для сжатия и распаковки файлов. Часто, при загрузке релиза программы или серии больших файлов или изображений, мы можем получить их в формате <code>.tar</code>, <code>.gz</code>, или даже <code>.tar.gz</code>. <code>tar</code> и <code>gz</code> - это разные программы. <code>tar</code> - это формат архива набора файлов, а <code>gz</code> - это формат сжатия информации. В большинстве случаев можно использовать файловый менеджер компьютера, он способен обрабатывать эти форматы, но иногда нужно распаковать файл в командной строке (например, на удаленном сервере). Вот самые распространенные команды.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Создяние .tar-архива</span></span><br><span class="line"><span class="comment"># c - создать, v - подробный вывод, f - формат tar</span></span><br><span class="line">tar cvf archive.tar file1 file2 file3 ... filen</span><br><span class="line"></span><br><span class="line"><span class="comment"># Перечислить файлы в архиве .tar</span></span><br><span class="line"><span class="comment"># t - режим списка</span></span><br><span class="line">tar tvf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Распаковка .tar-файла</span></span><br><span class="line"><span class="comment"># x - разархивировать, v - подробный вывод, f - tar-формат</span></span><br><span class="line">tar xvf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Сжать файл или архив</span></span><br><span class="line">gzip archive.tar <span class="comment"># создать archive.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Разархивация </span></span><br><span class="line">gunzip archive.tar.gz</span><br></pre></td></tr></table></figure>
<p>Есть еще несколько других флагов, управляющих работой с утилит сжатия / архивирования.</p>
<h1 id="Advanced-Bash"><a href="#Advanced-Bash" class="headerlink" title="Bash, новый уровень"></a>Bash, новый уровень</h1><p>Не все из вышеперечисленного относится непосредственно к концепциям bash, но их важно знать, даже если они не используются ежедневно. То, что будем изучать далее показывает истинную мощь оболочки bash. Темы следующие.</p>
<ul>
<li>Регулярные выражения, используемые в сценариях</li>
<li>Сценарии Bash</li>
<li>Виртуальные машины и SSH </li>
<li>Работа с сетью в командной строке</li>
<li>Управление процессами</li>
<li>Управление системой</li>
</ul>
<h2 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Регулярные выражения"></a>Регулярные выражения</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/NhcaKdt3NdM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Есть мнение, что язык регулярных выражений сложнее, чем он должнен быть. Есть много вариантов и мелких деталей, которые надо знать о регулярных выражениях, и, кроме того, существует множество различных разновидностей регулярных выражений (python, extended, rust и т. Д.). Несмотря на это, есть всего несколько основных концепций, которые нужно понимать о регулярных выражениях, что делает использование любых регулярных выражений эффективным.</p>
<p>Регулярные выражения существуют потому, что программы поиска текста по строке иногда недостаточно. Приведем ряд часто встречающихся практических примеров.</p>
<p>Ранее был создан скрипт на Microsoft Excel VBA, запускающий функции из одной динамической библиотеки. Код этой библиотеки недоступен, поэтому пришлось использовать его с некоторым ограничением. Целью эксперимента была возможность открытия новой книги Excel при каждом вызове функции. В каждой книге находятся данные, которые нужно скопировать в основную книгу, однако не было возможности определить имя этой новой книги. К счастью, Excel открывает новые книги и называет их “Book1”, “Book2”, “Book3”, “Book4” и т.д. Зная, что новые книги всегда будут содержать слово «Book» в начале, можно использовать регулярное выражение для их идентификации. Полученное регулярное выражение довольно просто и выглядит так: <code> ^Book[0-9]+</code>. Не обращая внимания на то, что показанный синтаксис пока вам не понятен, выражение ищет слова, начинающиеся с «Book» и заканчивающиеся одним или более цифрами.  </p>
<p>Более распространенным примером регулярных выражений является поиск в больших документах адресов электронной почты или номеров телефонов или даже проверка ввода данных пользователем в веб-приложении. Скорее всего, не потребуется использовать регулярные выражения ежедневно, мы не будем давать все мельчайшие детали, забываемые к концу дня. Вместо этого покажем общую методологию использования регулярных выражений, полезную на практике. Поиск Google дает результаты для конкретных случаяев использования.</p>
<p>Прежде всего надо сказать, что существует множество различных версий регулярных выражений. Вот три разных способа использования одного и того же регулярного выражения:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Пример использования регулярных выражений в Javascript для сопоставления строки с шаблоном "3 или более цифры"</span></span><br><span class="line"><span class="keyword">let</span> myRegExp = <span class="regexp">/[0-9]{3,}/</span></span><br><span class="line"><span class="keyword">let</span> myStringToMatch = <span class="string">'345'</span></span><br><span class="line"></span><br><span class="line">myRegExp.exec(myStringToMatch);  <span class="comment">// ["345", index: 0, input: "345", groups: undefined]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Это то же регулярное выражение, но в Python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">result = re.search(<span class="string">'[0-9]{3,}'</span>, <span class="string">'345'</span>)</span><br><span class="line"></span><br><span class="line">print(result.group(<span class="number">0</span>)) <span class="comment"># '345'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># И, наконец, то же выражение в оболочке bash с помощью команды grep</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"345"</span> | grep -E <span class="string">'[0-9]{3,}'</span> <span class="comment"># 345</span></span><br></pre></td></tr></table></figure>
<p>Обращаем внимание, что эти три языка используют регулярные выражения немного по-разному, но само абсолютно одинаково во всех случаях. Регулярные выражения легко реобразуются с одного языка на другой.  </p>
<p>Самый простой способ bpexbnm регулярные выражения - это показать примеры практического использования, и объяснить <em>зачем</em> использовать регулярное выражение для данной задачи. Начнем со следующего текста.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am some random text</span><br></pre></td></tr></table></figure>
<p>Если надо просто найти слово «random» в этом тексте, то просто используйте редактор или команду поиска текста. Например, я мог бы использовать grep следующим образом.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"I am some random text"</span> | grep <span class="string">"random"</span></span><br></pre></td></tr></table></figure>
<p>Это слишком просто и неинтересно. Все мы понимаем основную ижею сопоставления текстов друг с другом, но иногда не понятно, что это такое на самом деле. Если бы мы написали программу сопоставления текста, она состояла б из следующих шагов:</p>
<ol>
<li>Сохранить искомую строку в переменной </li>
<li>Открыть файл с текстом для поиска</li>
<li>Читать последовательно каждый символ в файле один за другим и проверять, соответствует ли этот символ первому символу в нашей строке поиска.</li>
<li>Если есть совпадение, перейти к следующей букве в строке поиска и проверить, соответствует ли она следующему символу в файле.</li>
<li>Если алгоритм дошел до конца строки поиска без несоответствий, значит, строка и тест сопоставимы.</li>
</ol>
<p>Это, конечно, слишком упрощенное объяснение, и подробнее тему можно изучить <a href="https://stackoverflow.com/a/1627904/7437737" target="_blank" rel="noopener">здесь</a>, если вам стало интересно. То, что мы только что рассмотрели, называется «буквальным сопоставлением текста» и может быть выполнено с помощью любой утилиты поиска текста. Но это также можно сделать с помощью утилиты, интерпретирующие регулярные выражения. При помощи функции регулярных выражений Perl, <code>grep</code> также находит это слово.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"I am some random text"</span> | grep -P <span class="string">"random"</span></span><br></pre></td></tr></table></figure>
<p>Интересно, чем данный пример отличается от предыдущего вариянта поиска. Пока что нет никакой разницы, кроме использвания флага <code>-P</code>, переключающего grep в режим интерпретации аргуманта как регулярного выражения. На этом этапе запоминаем, что регулярные выражения согут выполнять функцию буквального сопоставления текста. Но именно в этой точке становится интересным изучение регулярных выражений, потому что они могут не только устанавливать буквальное соответствие, но и сравнивать тексты с <em>шаблонам</em> символов. Давайте начнем с простого. Допустим, есть следующий текстовый файл с именем <code>http-request.txt</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Alt-Svc: quic=":443"; ma=2592000; v="44,43,39"</span><br><span class="line">Cache-Control: private, max-age=0</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Length: 72493</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 11 Feb 2019 21:40:25 GMT</span><br><span class="line">Expires: -1</span><br><span class="line">Server: gws</span><br><span class="line">Set-Cookie: 1P_JAR=2019-02-11-21; expires=Wed, 13-Mar-2019 21:40:25 GMT; path=/; domain=.google.com</span><br><span class="line">Set-Cookie: SIDCC=AN0-TYtZ7bElYEE0wy8nAaXHUK_GRAsuZzNu7r5OhKVGKwr7a-m7ctz5IIHoZcvmh2s9xuDt0gc; expires=Sun, 12-May-2019 21:40:25 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">Alt-Svc: quic=":443"; ma=2592000; v="44,43,39"</span><br><span class="line">Cache-Control: private, max-age=0</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Length: 72470</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 11 Feb 2019 21:44:38 GMT</span><br><span class="line">Expires: -1</span><br><span class="line">Server: gws</span><br><span class="line">Set-Cookie: 1P_JAR=2019-02-11-21; expires=Wed, 13-Mar-2019 21:44:38 GMT; path=/; domain=.google.com</span><br><span class="line">Set-Cookie: SIDCC=AN0-TYsHoOeMCDEAZfNd9umwLDXDEHqyGfAImuc08v4h2e1B1hSKxGQAq7iVt0xFlQKLzVlgSTM; expires=Sun, 12-May-2019 21:44:38 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">Alt-Svc: quic=":443"; ma=2592000; v="44,43,39"</span><br><span class="line">Cache-Control: private, max-age=0</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Length: 72464</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 11 Feb 2019 21:46:36 GMT</span><br><span class="line">Expires: -1</span><br><span class="line">Server: gws</span><br><span class="line">Set-Cookie: 1P_JAR=2019-02-11-21; expires=Wed, 13-Mar-2019 21:46:36 GMT; path=/; domain=.google.com</span><br><span class="line">Set-Cookie: SIDCC=AN0-TYuz2RnQRkvCL-vKi53aZ9wq43igGogt5iPF1aveuchWK1_5cZsxzom9-PWiJjy8Sk7bvgY; expires=Sun, 12-May-2019 21:46:36 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br></pre></td></tr></table></figure>
<p>Выше приведены три <em>разных</em> заголовка HTTP-ответов, полученные в результате запуска трех запросов к сайту <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>. Как видите, все они по структуре похожи друг на друга, однако, их не считают строгоструктурированными. Эти ответы - идеальный текст, который будем далее использовать для изучения регулярных выражений. Допустим, надо получить дату и время каждого запроса в каждом ответе. Делается это легко: надо найти три строки (в каждом из трех запросов есть дата) с помощью регулярного выражения.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat http-request.txt | grep -P <span class="string">"^Date.+"</span></span><br></pre></td></tr></table></figure>
<p>При выполнении эта команда найдет и распечатает требуемые три строки с датой ответа. Часть «Date» в регулярном выражении в принципе понять несложно, а что означает часть «.+»? Что обозначает символ <code>^</code>, находящийся в начале выражения? Если из выражения убрать две последние составляющие, то «Date» будет найдено три раза, но требуемой информации по дате не будет получено. Это прекрасная возможность представить «метасимволы». В регулярных выражениях поведение следующих символов отличается от символов, рассмотренных ранее: <code>. ^ $ * + ? { } [ ] \ | ( )</code></p>
<p>Понимание функций каждого из этих символов - ключ к возможности использования регулярных выражений. При чтении файла регулярное выражение будет обрабатывать строки одну за другой (каждая строка обозначена символом <code>\n</code>). Созданные регулярные выражения проверяются на каждой строке файла. Можно сделать вывод, что «граница» применимости регулярного выражения - это одна строка текста. Часто бывает полезно обозначать начало и конец строки в шаблонах выражений. Например, в списке телефонных номеров можной найти заданный код зоны.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">234-234-1920</span><br><span class="line">121-726-1382</span><br></pre></td></tr></table></figure>
<p>В строке 1 код города такой же, как и следующие за ним три числа. Используя символ <code>^</code> в регулярном выражении, выделяем только первые три символа.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat phone-numbers.txt | grep -P <span class="string">"^234"</span></span><br></pre></td></tr></table></figure>
<p>Это регулярное выражение будет соответствовать только коду города первого телефонного номера. Теперь предположим, надо сопоставить все строки текста, заканчивающиеся вопросительным знаком.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentences.txt</span><br><span class="line"></span><br><span class="line">The regex will not match me.</span><br><span class="line">The regex will not match me either.</span><br><span class="line">But wouldn't it make sense that the regex matched me?</span><br></pre></td></tr></table></figure>
<p>Так как <code>?</code> - это специальный символ, его надо "экранировать" бэкслешем, если он используется как букву.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sentences.txt | grep -P <span class="string">".+\?$"</span></span><br></pre></td></tr></table></figure>
<p>В данном примере шаблон соответствует тексту всей строки. В шаблоне конец строки обозначен вопросительным знаком (часть искомой строки) и специальным символом <code>"$"</code>. Символ $ противоположен свойствами <code>^</code>, представленный ранее.</p>
<p>Символ <code>.</code> соответствует любому символу входной строки. При использовании в шаблонах <code>.</code> не соответсвует только символам "перевод строки" и "возврат каретки", обозначающие конец строки. Есть также еще три других специальных символа, которые соответствуют другим типам символов.</p>
<ul>
<li><code>.</code> - соответствует любому символу</li>
<li><code>\d</code> - соответсвует одной из цифр (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</li>
<li><code>\s</code> - соответствует любым символам, интерпретируемым как "пустое пространство", включая "перевод строки", "возврат каретки" </li>
<li><code>\w</code> - соответствует любому символу алфавита или цифре</li>
</ul>
<p>Если вышепреведенный символ перевести в верхний регистр (<code>\D</code>, <code>\S</code>, <code>\W</code>) создает противоположный эффект. Используя эти новые знания, попробуем сопоставить следующую строку текста.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You cannot match me because you don't know what a quantifier is!</span><br></pre></td></tr></table></figure>
<p>???Если бы мы попытались соответствовать этой линии, используя только навыки, которые мы знаем сейчас, мы могли бы попробовать что-то вроде этого: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"You cannot match me because you don't know what a quantifier is"</span> | grep -P <span class="string">"^Youis$"</span></span><br></pre></td></tr></table></figure>
<p>Почему ничего не получилось? Мы хотим найти “You” вначале строки (<code>^</code>) и “is” в конце (<code>$</code>). Проблема в том, что сопоставление слов (букв) в центре строки не сделано. Добавив <code>.</code> в центр шаблона регулярного выражения, вероятно проблема будет решена! Попробуем.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"You cannot match me because you don't know what a quantifier is"</span> | grep -P <span class="string">"^You.is$"</span></span><br></pre></td></tr></table></figure>
<p>К сожалению, это тоже не сработает. Причина, по которой это не работает, заключается в том, что <em>количество</em> символов в центре не указано, т.е., то, что между "You" и "is!". Для этого используются специальные символы <code>*</code>, <code>+</code>, <code>?</code> и <code>{}</code>.</p>
<ul>
<li><code>*</code> - сопоставляет 0 или больше символа, стоящих в шаблоне слева от символа</li>
<li><code>+</code> - сопоставляет 1 или больше -"-</li>
<li><code>?</code> - Сопоставляет 0 или 1 символ -"-</li>
<li><code>{1}</code> - Сопоставляет в точности 1 символ -"-</li>
<li><code>{1,}</code> - Сопоставляет 1 или больше -"- (так же как <code>+</code>)</li>
<li><code>{2,6}</code> - Сопоставляет от 2 до 6 символов -"-</li>
</ul>
<p>Эти конструкции называются “кванторами” и являются очень важными в формировании регулярных выражений. Заметим, что <em>любой</em> квантор может быть определен при помощи <code>{}</code>, но на практике использование <code>*</code>, <code>+</code> и <code>?</code> позволяет создавать регулярные выражения быстрее При помощи кванторов, завершим формирование нашего выражения.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"You can match me now because you know what a quantifier is"</span> | grep -P <span class="string">"^You.+is$"</span></span><br></pre></td></tr></table></figure>
<p>Что имеем теперь: сопоставляем “You” в начале строки (<code>^</code>), затем 1 или больше <em>любых</em> символов (<code>.+</code>) и в конце сопоставляем “is” в конце строки (<code>$</code>). Приведм еще несколько примеров, которые демонстрируют использование кванторов.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Одна буква</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a+"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a*"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a?"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a{1}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a{1,}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a{0,1}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Двойная буква</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a"</span> <span class="comment"># Соответствует первая буква только</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a+"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a*"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a?"</span> <span class="comment"># Только первая буква соответствует</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a{1}"</span> <span class="comment"># Сопоставяется только первая буква</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a{1,}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a{0,1}"</span> <span class="comment"># Сопоставляется только первая буква</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a{0,1}$"</span> <span class="comment"># Нет никакого соответствия!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using metacharacters</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w"</span> <span class="comment"># соответствие!/s107&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w+"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w*"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w?"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w{1}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w{1,}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w{0,1}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Другое использование метасимволов (соответствие чему-либо, кроме цифр)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D+"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D*"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D?"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D{1}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D{1,}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D{0,1}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10 разных способов найти одно и то же слово</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"regexp"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^regexp"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^reg\w*"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^reg\w*$"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^\w*$"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"\w*"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^\w+"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^regex\w?$"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"\D{1,}"</span> <span class="comment"># соответствие!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^\S{1}\w+$"</span> <span class="comment"># соответствие!</span></span><br></pre></td></tr></table></figure>
<p>Как вы можете видеть в последних двух строках, есть много способов сопоставить один и тот же текст. Целых 40 различных регулярных выражений, все соответствуют строке «regexp»! И это даже без учета последнего метасимвола, который сейчас посмотрим. Все это время классы символов, которые представляют собой выражения, содержащиеся в <code>[]</code>, даже не были упомянуты.  Они пропущены потому, что при их использовании, меняется поведение правил. Метасимволы (<code>. ^ $ * + ? { } [ ] \ | ( )</code>) меняют свое поведение, если их поместить в квадратные скобки, более того, можно создавать регулярные выражения без выражений в 99% случаев! Классы символов позволяют упрощать выражения, поэтому посвятим им немного времени.  </p>
<p>Классы символов можно вопринимать как просто символ, но имеющий множество возможностей. Например, следующий класс символов представляет одну из букв нижнего регистра в алфавите, но только одну, так как добавлен квантор <code>[a-z]{1}</code>. Аналогично можно задать только первые 13 букв алфавит: <code>[a-m]</code>. Это распространяется и на цифры. Выражение <code>[0-9]</code> сопоставляется с одной из цифр, и эквивалентна классу <code>\d</code>. Выражение <code>[0-9a-zA-Z_]</code> представляет все символы английского алфавита и точно эквивалентен <code>\w</code>.</p>
<p>Тепер те, кто пользовался <code>[0-9]</code> могут смело переходит на использование <code>\d</code>! Такой подход позволяет как минимум сокращать размер выражения. Выражения со скобками полезны, если полный класс не является допустимым в решении задачи. Например, нужны только цифры от 1 до 5. Т.к. нет соответствующего класса, нужно использовать <code>[1-5]</code>.</p>
<p>При использовании классов символов, есть несколько проблем, на которые надо обратить внимание. They all relate to the use of metacharacters and how those metacharacters behave in a character class. In general, I would not recommend trying to use any metacharacter inside a character class (<code>[]</code>), but if you do, here are the rules.</p>
<ul>
<li>The <code>^</code> character does not mean the beginning of a line. Это символ отрицания (дополнения).  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This expression will match. Первый символ "^" означает "начало строки", однако </span></span><br><span class="line"><span class="comment"># второй "^" (внутри квадратных скобок) означает "отрияание" (дополнение).  Следовательно, это выражение</span></span><br><span class="line"><span class="comment"># будет соответствовать одному или более символам, начиная с начала строки,</span></span><br><span class="line"><span class="comment"># не являющихся цифрами. </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^[^0-9]+"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Символ "<code>.</code>" соответствует символу "точка", если помещен в квадратные скобки</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Можно подумать, что это выражение соответствует строке, но это не так.  Это выражение соответствует</span></span><br><span class="line"><span class="comment"># олдному или более символам "точка", находящихся в начале строки.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^[.]+"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># А вот это выражение соответствует!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp..."</span> | grep -P <span class="string">"^regexp[.]+"</span></span><br></pre></td></tr></table></figure>
<p>Наконец, надо вкратце упомянуть, почему мы не говорили о метасимволах <code>|</code> and <code>()</code> Оба этих сивола относятся к теме «группы», которая позволяет группировать различные части вашего регулярного выражения. Если регулярное выражение сильно длинное, бывает полезно сгруппировать различные его части. Причина, по которой мы не затрагивали эту тему, заключается в том, что эта тема гораздо более полезна в программах обычных языков программирования, таких как Python. В программах, использующих регулярные выражения, можно ссылаться на разные группы регулярных выражений, после получаения удачного соответствия. В рамках bash регулярные выражения эти функции, как правило, не используются.</p>
<p>Однако…</p>
<p>Что нам глобально дает испольщование регулярных выражений?? </p>
<p><em>Есть МНОГО способов их написать</em>.</p>
<p>В оставшейся части этого раздела рассмотрим практический пример использования новых навыков составлений регулярного выражения. Попробуем решить проблему двумя разными способами, используя два разных типа синтаксиса регулярных выражений, и продемонстрируем различные способы решать задачи.</p>
<h3 id="Detailed-Example-Regular-Expression"><a href="#Detailed-Example-Regular-Expression" class="headerlink" title="Подробный пример использования регулярного выражения"></a>Подробный пример использования регулярного выражения</h3><p>Пусть задан следующий файл с именем <code>email-addresses.txt</code> : </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jon23@gmail.com</span><br><span class="line">bob879@yahoo.com</span><br><span class="line">not an email</span><br><span class="line">sally2@customsite.com</span><br><span class="line">fred.jones@hotmail.com</span><br><span class="line">не адрес электронной почты</span><br></pre></td></tr></table></figure>
<p>Изучение вариантов использования регулярных выражений для распознавания всех четырех адресов продемонстрирует множество рассмотренных концепций. Начнем с сопоставления всех символов при помощи метасимвола <code>.</code>, соспоставление начинается с начала каждой строки (<code>^</code>). </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+"</span></span><br></pre></td></tr></table></figure>
<p>Выражение, которое мы только что составили, означает, что начиная с начала каждой строки и ищем <em>любой</em> символ (за исключением концов строк) в количестве один или более символов. Можно легко написать это выражение иначе: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]{1,}"</span></span><br></pre></td></tr></table></figure>
<p>Как видите, регулярные выражения можно использовать по-разному. В этой версии решается <em>таже</em> задача, но при помощи другого синтаксиса. Символ <code>^</code>, ка и раньше обозначает начало строки. Символы <code>[^\r\n]</code> обозначают <em>любые</em> символы, которые <em>не</em> (<code>^</code>) являются концами строк (<code>\r</code>, <code>\n</code>). Обратите внимание, размещение <code>^</code> внутри выражения действует как отрицание, а не «начало строки». Помните, что символы ведут себя по-разному, когда они помещаются внутрь выражения, а также в наборы сиволов! Наконец, надо сопоставлять эти символы один или более раз, поэтому используется форма <code>{1,}</code>. Запятая после "1" означает, что надо именно 1 или <em>более</em> совпадений. В любом случае, если запустить сопоставление, все шесть строк текстового файла будут сопоставимы. Поскольку требуется найти только адреса электронной почты, нам нужно настроить выражение. Сделаем этот также разными способами, которые <strong>делают одно и то же</strong>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]{1,}@.{1,}"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@.+"</span></span><br></pre></td></tr></table></figure>
<p>Два приведенных выше выражения соответствуют четырем адресам электронной почты, исключая две другие строки. Все, что нужно было сделать, - это добавить символ «@», до и после него - наборы любых символов (кроме концов строк). Замечательно, но что будет, если изменить текстовый файл так, чтобы он выглядел так: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jon23@gmail.com</span><br><span class="line">bob879@yahoo.com</span><br><span class="line">not an email</span><br><span class="line">sally2@customsite.com</span><br><span class="line">this line has an @ symbol in it so it will mess with our regex</span><br><span class="line">fred.jones@hotmail.com</span><br><span class="line">not an email address</span><br></pre></td></tr></table></figure>
<p>Теперь, если запустить регулярные выражения, в результате сопоставлены будут все адреса электронной почты, а также и новая добавленная строка. Как видите, в зависимости от сложности текста, возможно, придется попробовать вариантов выражений, прежде чем получится правильное регулярное выражение. Нужно изменить правую половину регулярного выражения на следующий вариант.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]{1,}@.{1,}\.com"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@.+\.com"</span></span><br></pre></td></tr></table></figure>
<p>Теперь снова сопоставляются только адреса электронной почты. Все, что было сделано, - это добавление <code>\ .com</code> в конце нашего регулярного выражения, при этом требуем <em>буквального</em> совпадения (пришлось «экранировать» точку, потому что в противном случае она относится ко всем символам, как это было в предыдущих вариантах выражений). Чтобы экранировать специальный символ, используется обратная косая черта непосредственно перед экранируемым символом). Но что, если изменить текстовый файл еще раз следующим образим?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jon23@gmail.com</span><br><span class="line">bob879@yahoo.com.yahoo.com</span><br><span class="line">not an email</span><br><span class="line">sally2@customsite.net</span><br><span class="line">this line has an @ symbol in it so it will mess with our regex</span><br><span class="line">fred.jones@hotmail.com</span><br><span class="line">not an email address</span><br></pre></td></tr></table></figure>
<p>Здесь сделано два изменения. Во-первых, добавлен недействительный адрес электронной почты. “<a href="mailto:bob879@yahoo.com.yahoo.com" target="_blank" rel="noopener">bob879@yahoo.com.yahoo.com</a>“ - очевидно неправильный электронный адрем, надо выкинуть его из результата. Второе - “<a href="mailto:sally2@customsite.net" target="_blank" rel="noopener">sally2@customsite.net</a>“ теперь без домена “.com” в конце, и теперь выражение его не находит. Изменим еще раз регулярные выражения, чтобы они соответствовали только действительным адресам электронной почты.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]{1,}@[a-zA-Z0-9]{1,}(.com|.net){1}"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@\w+(.com|.net){1}"</span></span><br></pre></td></tr></table></figure>
<p>Эти примеры приблилили нас к решению задачи. В обоих выражениях заменена строка <code>\.com</code> на <code>(.com|.net){1}</code>, чтобы искать <em>или</em> “.com” или “.net” в email в точности один раз. Затем в первом регулярном выражении заменен <code>.{1,}</code> на <code>[a-zA-Z0-9]{1,}</code>, который теперь не будет соответствовать «yahoo.com.yahoo.com», потому что точки не входят в набор символов. Аналогично во втором выражении <code>.+</code> заменено на <code>\w+</code>, что распознает эти же подстроки. Единственная проблема, котрая еще не решена заключается в том, что регулярные выражения по-прежнему соответствуют первой части “<a href="mailto:bob879@yahoo.com.yahoo.com" target="_blank" rel="noopener">bob879@yahoo.com.yahoo.com</a>“. Эта строка <em>вообще</em> не должна быть сопоставлена. Чтобы исправить это, модифицируем еще раз выражения.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]{1,}@[a-zA-Z0-9]{1,}(.com|.net){1}$"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@\w+(.com|.net){1}$"</span></span><br></pre></td></tr></table></figure>
<p>Все, что было сделано, - это добавиление <code>$</code>, сопоставляемый с концом строки. Так же, как символ <code>^</code> обозначает начало строки, использование <code>$</code> в конце выражений указывает конец этой же строки. Последнее изменение устраняет неверные адреса электронной почты!</p>
<h2 id="Bash-Scripting"><a href="#Bash-Scripting" class="headerlink" title="Сценарии Bash"></a>Сценарии Bash</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/JdvG_H07CNc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>В этом руководстве рассмотрено много команд и концепций. Большинство изученных команд (за исключением <code>awk</code>) предназначены только для использования в командной строке, но что, если попробовать поместить некоторые из них в сценарий (программу на языке bash)? В принципе, всегда можно набить длинную и сложную команду в строке и выполнить ее, но она не будет сохранена, а набивать ее каждый раз совсем неудобно. Разработка сценариев Bash решают эту проблему, позволяя писать обычные команды bash в файле сценария, а затем исполнять его. Сценарии полезны при решении повторяющихся задач. Например, возможно, бывает необходимо ежедневно очищать определенную папку на компьютере и помещать ее содержимое в папку-архив с текущей датой. Такие задачи решаются при помощи сценариев bash, и здесь мы рассмотрим, как это делается. Во-первых, нам нужно понять основы разработки сценариев.</p>
<p>Самая простая форма файла сценария показана ниже. Файл скрипта называется <code>simple-script.sh</code> где <code>.sh</code> - это расширение файла для сценария (оно не обязательно должно быть таким, но рекомендуется именно так его задавать). Разрешения на этот файл - <code>744</code>, что означает, что только владелец скрипта может его изменять или выполнять.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I am a useless, basic script"</span></span><br></pre></td></tr></table></figure>
<p>Заапуск скрипта осуществляется двумя способами.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash simple-script.sh </span><br><span class="line"></span><br><span class="line">./simple-script.sh</span><br></pre></td></tr></table></figure>
<p>Обратите внимание, что в верхней части файла есть что-то, называемое «шебанг» (<code>#!/bin/bash</code>), сообщающий операционной системе интерпретатор, который будет исполнять файла-скрипт. В примере сообщается, что он скритп исполняется оболочкой bash, которая находится в директории <code>/bin</code> на компьютере. В принципе этот шабанг обычно не обязательный, поскольку в большинстве случаев оболочка bash будет выполнять сценарии по умолчанию с помощью bash, однако добавления его в скрипт - это хорошая практика и увеличивает переносимость кода скрипта.</p>
<p>Приведенный пример рабочий, но, очевидно, бесполезен. В этом разделе приведем наиболее важные компоненты сценария bash, включая </p>
<ul>
<li>Объявления переменных</li>
<li>Встроенные переменные</li>
<li>Параметры запуска программы</li>
<li>Чтение пользовательского ввода</li>
<li>Циклы "for"</li>
<li>Оператор "if-then"</li>
</ul>
<p>Используя эти концепциии можно выполнить 95% задач. Конечно, есть задачи, при решении которых вышеуказанных концепций будет недостаточно, тем не менее рассмотрим только часто используемые конструкции. Далее в этом разделе будем полагать, все изменения вносятся каждый раз в файл <code>shell-scripting-basics.sh</code>, и именно он запускается, если не указано иное.</p>
<h3 id="Variable-declarations"><a href="#Variable-declarations" class="headerlink" title="Объявления переменных"></a>Объявления переменных</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MY_VARIABLE=<span class="string">"значение"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Переменные также могут использоваться в строках, ограниченных двойными кавычками: <span class="variable">$MY_VARIABLE</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Но не в строки, ограниченные одинарными кавычками. Значения переменной $MY_VARIABLE не будет отображено'</span></span><br></pre></td></tr></table></figure>
<p>Объявление и использование переменных в сценариях bash достатосно просто, поэтому не будем тратить много времени на них.</p>
<h3 id="Built-In-Variables"><a href="#Built-In-Variables" class="headerlink" title="Встроенные переменные"></a>Встроенные переменные</h3><p>Есть несколько встроенных переменных, которые можно использовать в сценарии bash. Они перечислены ниже.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span>  <span class="comment"># Вывести наименование скрипта - shell-scripting-basics.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span>  <span class="comment"># Выводит первый аргумент скрипта</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span>  <span class="comment"># Вывести второй аргумент скрипта</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$3</span>  <span class="comment"># Вывести третий... надо далее продолжать??? </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span>  <span class="comment"># Выводит количество аргументов, переданных скрипту</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span>  <span class="comment"># Выводит все аргументы, переданные скрипту</span></span><br><span class="line"><span class="built_in">echo</span> $$  <span class="comment"># Выводит число - идентификатор процесса (process ID)</span></span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment"># Выводит код завершения предыдущего процесса</span></span><br></pre></td></tr></table></figure>
<h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Аргументы командной строки"></a>Аргументы командной строки</h3><p>Сценарий bash может принимать аргументы через командную строку. Выполним следующий сценарий. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Скрипт <span class="variable">$0</span> вычисляет: "</span> $((<span class="variable">$1</span>+<span class="variable">$2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./shell-scripting-basics.sh 3 9</span><br><span class="line"></span><br><span class="line"><span class="comment"># Скрипт ./shell-scripting-basics.sh вычисляется в:  12</span></span><br></pre></td></tr></table></figure>
<p>Данный скрипт вычисляется в “Скрипт ./shell-scripting-basics.sh вычисляется в: 12”</p>
<p>Итак, использование встроенных переменных внутри скриптов возможно.</p>
<h3 id="Reading-user-input"><a href="#Reading-user-input" class="headerlink" title="Чтение пользовательского ввода"></a>Чтение пользовательского ввода</h3><p>Можно производить читение пользовательских данных в программе сценария. Это похоже на чтение аргументов из командной строки, но данные (значения переменных) вводятся пользователем во времени выполнения программы.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Производим чтение пользовательских данных в переменную_input</span></span><br><span class="line"><span class="built_in">read</span> user_input</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Пользователь ввел: <span class="variable">$user_input</span>"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./shell-scripting basics</span><br><span class="line">введенные данные</span><br><span class="line">Пользователь ввел: введенные данные</span><br></pre></td></tr></table></figure>
<p>Если надо защитить (скрыть) ввод пользователя (например, для ввода пароля), добавляется <code>-s</code> в начале команды: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -s user_input</span><br></pre></td></tr></table></figure>
<h3 id="for-loops"><a href="#for-loops" class="headerlink" title='Циклы "for"'></a>Циклы "for"</h3><p>Синтаксис цикла в bash: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>В этом сценарии перебираются все переданные программе аргументы. Напомним, что <code>$@</code> - встроенная переменная, содержащая значения всех аргументов программы. Можем определить массив переменных в bash, и также перебрать их.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -a my_array=(<span class="string">'string 1'</span>, <span class="string">'string 2'</span>, <span class="string">'string 3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"<span class="variable">${my_array[@]}</span>"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$item</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>Как видите, форма представления массивов в bash немного странная. Можно использовать цикл for для перебора множества файлов. Такие операции очень часто можно найти сценариях, и вам, возможно, придется разрабатывать что-то подобное.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Перейти в домашний каталог</span></span><br><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Символ * обозначает все файы и подкаталоги в текущем каталоге</span></span><br><span class="line"><span class="comment"># Этот скрипт, по сути, команда `ls`</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="if-then-statements"><a href="#if-then-statements" class="headerlink" title='Оператор "if-then"'></a>Оператор "if-then"</h3><p>Оператор оставлен if-then напоследок, потому что он немного сложноватый для понимания. Форма представления выражений проверки исинности, которая используется в операторе if-then, базируется на команде <code>test</code> команду, ее детальная информация представлена в руководстве <code>man test</code>. Для большинства команд в bash справочные страницы труднопонимаемые и обычно бесполезны для поиска "быстрых" ответов. Странно, что справочная страница для <code>test</code> проста и понятна. Поэтому мы не будем перечислять все доступные варианты использования test и предполагаем знакомиться с руководством <code>test</code>. Ниже показано простое использование <code>test</code> в командной строке (вне сценария).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> 2 -eq 2; <span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> 2 -eq 3; <span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>Запустив эти две команды, получи результат 0 и 1. Эти числа являются значениями завершения команды test и хранятся во встроенной переменной <code>$?</code>. Каждая показанная выше строка на самом деле представляет собой две команды. Первая команда - проверка условия, а вторая - печать кода выхода предыдущей команды (которая была test). Использование test в сценарии в операторе if-then выглядит следующим образом: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ 2 -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"2 действительно равно 2!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>Будет напечатано «2 действительно равно 2» потому, что выражение истинно (код выхода 0). Также можно вычислять другие условные выражения. Например, можно просматривать все файлы в домашнем каталоге, и если очередной файл является подкаталогом, печатаем «$name - это каталог», а если нет, «$name - это файл».</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="variable">$name</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> - это каталог!"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> - это файл!"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>Флаг <code>-d</code> проверяет, является ли name каталогом. Если это так, возвращается истина (код выхода 0).</p>
<p>Теперь, когда вы знакомы с основами создания сценариев bash, можно перейти к практическому примеру проверки определенной папки на наличие файлов и их перемещения в архив. Будем проверять каталог на наличие файлов, которые не изменялись в течение семи или более дней, если это тка, то помещаем их в папку архива с текущей датой. Скрипт будет использовать команду <code>find</code>, которую изучили ранее!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line">todays_date=$(date +%Y-%m-%d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Сначала проверить, существует ли папка с архивами</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">'/home/zach/archives/'</span> ]; <span class="keyword">then</span></span><br><span class="line">	mkdir /home/zach/archives/</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Проверить, создана ли папка с текущей датой</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"/home/zach/archives/<span class="variable">$todays_date</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">	mkdir /home/zach/archives/<span class="variable">$todays_date</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Здесь немного замудреное выражение.  Выражение подсмотрено на StackOverflow, оно передает (pipe) вывод команды find</span></span><br><span class="line"><span class="comment"># в цикл do-while, потому что команда exec в find приводит к ошибке отказа в доступе, если запущена в скрипте</span></span><br><span class="line">find /home/zach/folder-to-clean -<span class="built_in">type</span> f -mtime -7 | </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	mv <span class="variable">$filename</span> /home/zach/archives/<span class="variable">$todays_date</span>/</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Функции"></a>Функции</h3><p>Язык программирования - это не язык программирования, если в нем нет функций. Расмотрим базовый синтаксис для создания и последующего вызова функции в сценарии bash.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">some_function</span></span> () {</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Если вы передадите аргументы в эту функцию, то функция их распечатает</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># Функции не были переданы аргументы</span></span><br><span class="line"><span class="built_in">эхо</span><span class="string"> «Я - функция, и мне не было передано никаких аргументов»</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="comment"># Передан как минимум один аргумент, производим печать их всех</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"я здесь"</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Возврат значения изфункции, которое доступно позже с помощью встроенной переменной $? </span></span><br><span class="line">        <span class="built_in">return</span> 20</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># вызов функции</span></span><br><span class="line">some_function</span><br><span class="line"></span><br><span class="line"><span class="comment"># вызов нашей функции с аргументами</span></span><br><span class="line">some_function <span class="string">"аргумент 1"</span> <span class="string">"аргумент 2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Печать возвращаемого значения 20</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
<p>Есть практически бесконечные количество возможностей использования сценариев bash. Пишите свои скрипты, и будет вам счастье!</p>
<h2 id="Virtual-Machines-and-SSH-Protocol"><a href="#Virtual-Machines-and-SSH-Protocol" class="headerlink" title="Виртуальные машины и протокол SSH"></a>Виртуальные машины и протокол SSH</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/wWrQdkoBZEI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Эта тема может довольно обширна, поэтому, как и прежде, не будем сильно углубляться. Рассмотрим только следующее: </p>
<ul>
<li>Как настроить открытую и закрытую пару ключей для доступа по ssh</li>
<li>Добавление ключей в ssh-agent (если приемлемо)</li>
<li>Как использовать SSH для подключения к удаленному компьютеру</li>
<li>Как передавать файлы между локальным и удаленным компьютером с помощью<code> scp</code></li>
<li>Как скачивать файлы из интернета</li>
<li>Как использовать VSCode с вашим VPS</li>
</ul>
<p>В дальнейших примерах в основном использован хостинг в компании Digital Ocean, настройка и подключение к виртуальному частному серверу в Digital Ocean также будет продемонстрировано. Эти концепции применимы повсеместно, независимо от того, используются ли AWS, Azure и т.д. Когда создается VPS в Digital Ocean, также называемый «капля», программное обеспечение хостинга спрашивает пользователя, хочет ли он подключиться к машине с помощью пароля или ключа SSH. Очень удобно подключаться при помощи SSH-ключа, поэтому сначала покажем, как создать этот ключ на локальном компьютере. Процесс подключения к VPS состоит из следующих шагов.</p>
<ol>
<li>Пользователь создает пару ключей SSH (закрытый и открытый) на локальном компьютере.</li>
<li>Пользователь копирует <em>открытый</em> ключ в поле SSH хостинг-провайдера при настройке хоста</li>
<li>Подключение пользователя осуществляется через SSH, SSH проверит открытый и закрытый пару ключей, хранящиеся на локальном компьютере в каталоге <code>~/.ssh</code> с открытым ключом, хранящимся на VPS.</li>
<li>Если ключи подтверждены, пользователь получает удаленный доступ к VPS, а ваш IP-адрес сохраняется как «известный хост» на VPS.</li>
</ol>
<p>Итак, первый шаг требует создание пары ключей. Это делается в ОС Mac и Linux с помощью пакета OpenSSH. В терминале вводится следующую команду.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>Будет задан вопрос о каталоге, где будет храниться ключ. Правильное местоположение - какталог <code>~/.ssh</code>, но можно задать ему любое имя. Когда команда ssh-keygen запросит пароль, просто дважды нажмите ввод ничего не вводя, потому что нам не нужно защищать ключ паролем, поскольку мы используем этот ключ для идентификации локального компьютера. Новый ключ автора в <code>/home/zach/.ssh/id_digitalocean_rsa</code>.</p>
<p>Теперь нужно вывести на экран и скопировать в буфер обмена открытую часть ключа. Для этого надо набрать команду: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_digitalocean_rsa.pub</span><br></pre></td></tr></table></figure>
<p>Обращаем внимание на <code>.pub</code> в конце. Каждый раз, как содается пара ключей, один их них, <code>.pub</code>, всегда присутствует. Скопировав содержимое этого файла, вставьте его в поле ключа SSH в соответствующее поле при регистрации виртуальной машины хостинг-провайдере. В Digital Ocean это делается так.</p>
<img src="/blog/2019/bash-essentials/digital-ocean-key.png">
<p>Как только это сделано, можете создавать свою виртуальную машину. Теперь надо найти IP-адрес новой виртуальной машины и ввести в терминале следующую команду.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 root@157.230.167.2</span><br></pre></td></tr></table></figure>
<p>Эта команда должна подключить текущий терминал к новому VPS.  </p>
<h3 id="Permanently-Add-Keys-to-ssh-agent"><a href="#Permanently-Add-Keys-to-ssh-agent" class="headerlink" title="Добавление постоянных ключей в ssh-agent"></a>Добавление постоянных ключей в ssh-agent</h3><p>Обычно это не проблема для Linux, но на Mac нужно будет изменить некоторые настройки по умолчанию. По умолчанию любой ключ, который не является файлом <code>id_rsa</code> не будет добавлен ни в программу ssh-agent, ни в "связку ключей" Mac. Каждый раз, когда надо подключиться к виртуальной машине, нужно будет добавлять ключ ssh. Например, есть ключ под названием <code>digital-ocean</code>, который используется для входа цифровые "капли океана".</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Загружает необходимые переменные среды</span></span><br><span class="line"><span class="built_in">eval</span> `ssh-agent -s`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Добавляется ssh key</span></span><br><span class="line">ssh-add -K ~/.ssh/digital-ocean</span><br><span class="line"></span><br><span class="line"><span class="comment"># Подключение</span></span><br><span class="line">ssh -p 22 root@&lt;some-ip-address&gt;</span><br></pre></td></tr></table></figure>
<p>Чтобы избежать таких повторений при входе в систему Mac нужно будет изменить <code>~/.ssh/config</code> и добавить следующую запись: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentityFile ~/.ssh/digital-ocean</span><br></pre></td></tr></table></figure>
<p>Указание поля Host * обозначает возможность подключения к любому серверу. Символ * можно заменить доменом, например github.com. Кроме того, настройка сообщает агенту использовать связку ключей, добавлять ключи и использовать два файла идентификации, перечисленные как "пароли" к удаленным соединениям.</p>
<h3 id="From-local-computer-to-remote-machine"><a href="#From-local-computer-to-remote-machine" class="headerlink" title="С локального компьютера на удаленный"></a>С локального компьютера на удаленный</h3><p>Далее покажем, как передавать файлы между локальным и удаленным компьютером. Для этого используется утилита <code>scp</code>.</p>
<p>Например, загрузим <code>sample-file.txt</code> на удаленную машину: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r sample-file.txt root@157.230.167.2:~/</span><br></pre></td></tr></table></figure>
<p>В результате файл <code>sample-file.txt</code> будет загружен, используя пользователя <code>root</code>, файл будет помещени в домашний каталог <code>~/</code> на уделенной машине. Можно указать любое месторасположение размещения файлов на удаленном компьютере. Оно указывается после <code>:</code>, которое после IP-адреса.</p>
<h3 id="From-remote-machine-to-local-computer"><a href="#From-remote-machine-to-local-computer" class="headerlink" title="С удаленного компьютера на локальный"></a>С удаленного компьютера на локальный</h3><p>Чтобы загрузить файл с удаленного компьютера на локальный надо запустить следующую команду.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r root@157.230.167.2:~/sample-file.txt ~/Downloads</span><br></pre></td></tr></table></figure>
<p>Загруженный файл будет помещен в папку <code>~/Downloads</code> локального компьютера.</p>
<h3 id="Downloading-packages-to-your-remote-machine-with-wget"><a href="#Downloading-packages-to-your-remote-machine-with-wget" class="headerlink" title="Загрузка пакетов на удаленный компьютер с помощью wget"></a>Загрузка пакетов на удаленный компьютер с помощью wget</h3><p>Иногда нужно загрузить пакеты программного обеспечения из Интернета на VPS. Поскольку нет графического интерфейса, нужно выполнить команду в командной строке. Допустим, по какой-то причине надо загрузить картинку Google на VPS.</p>
<p>Вот няшная картинка хаски - <a href="https://cdn.orvis.com/images/DBS_SibHusky.jpg" target="_blank" rel="noopener">https://cdn.orvis.com/images/DBS_SibHusky.jpg</a></p>
<p>Загрузить ее это на наш VPS можно, используя следующую команду.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O my-custom-picture.jpg https://cdn.orvis.com/images/DBS_SibHusky.jpg</span><br></pre></td></tr></table></figure>
<p>В результате фотография будет загружена и сохранена под именем <code>my-custom-picture.jpg</code> каком-либо каталоге, из которого потом потребуется выполнять какие-либо команду.</p>
<h3 id="Using-VSCode-with-your-remote-machine"><a href="#Using-VSCode-with-your-remote-machine" class="headerlink" title="Использование VSCode через удаленное соединение"></a>Использование VSCode через удаленное соединение</h3><p>Конечно, можно использовать текстовый редактор Vim для решения всех задач в разработке программ прямо на VPS, но хорошо иметь под рукой многофункциональный текстовый редактор, такой как VSCode. Редактор VSCode может использоваться для редактирования файлов на VPS, это достигается при помощи команды <code>rmate</code>. Для включения этой функции откройте в VSCode и загрузите расширение (extension) под названием «Remote VSCode». После загрузки откройте настройки, набрав ctrl-shift + P и набрав “&gt;Preferences:Open User Settings”. Пролистайте вниз и найдите раскрывающийся список "Extensions" и выберите “Remote VSCode”. Далее требуется добавить следующие настройки: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Remote Host: 127.0.0.1</span><br><span class="line">Remote Port: 52698</span><br><span class="line">Remote Onstartup: True (will be a checkbox)</span><br></pre></td></tr></table></figure>
<p>Наберите ctrl-shift P и “&gt;Remote: Start Server”. Это запустит удаленный сервер. Теперь в локальном терминале наберите команду подключения к VPS.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 52698:127.0.0.1:52698 root@157.230.167.2</span><br></pre></td></tr></table></figure>
<p>Замените IP-адрес своим. Затем установите утилиту <code>rmate</code> на VPS.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/<span class="built_in">local</span>/bin/rmate https://raw.github.com/aurora/rmate/master/rmate</span><br><span class="line">sudo chmod a+x /usr/<span class="built_in">local</span>/bin/rmate</span><br></pre></td></tr></table></figure>
<p>Редактировать файлы на VPS с помощью VSCode можно, если выполнить команду в командной тсроке VPS!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmate sample-file.txt</span><br></pre></td></tr></table></figure>
<h2 id="Networking-on-Command-Line"><a href="#Networking-on-Command-Line" class="headerlink" title="Управление сетью в командной строке"></a>Управление сетью в командной строке</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/hGjF90P1Hr0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Приобретение навыков управления сетью в командной строке - это огромная и интересная задача. По этой теме написано много книг и учебников, поэтому не будем рассматривать все вопросы. В этом разделе описаны наиболее распространенные сетевые утилиты Bash, которые можно использовать для диагностики сетевых проблем на компьютере. Если вы совершенно не знакомы с концепциями сетей, то некоторый базовый уровень знаний можно поличить читая этот раздел.</p>
<h3 id="Your-home-network-and-the-internet"><a href="#Your-home-network-and-the-internet" class="headerlink" title="Сеть в доме и доступ в Интернет"></a>Сеть в доме и доступ в Интернет</h3><p>Чтобы разобраться в командах, которые далее будут запускаться, нужно иметь хотя бы базовое понимание сетевых технологий.</p>
<ol>
<li>Беспроводная карта компьютера</li>
<li>Маршрутизатор</li>
<li>Модем</li>
<li>Что такое Интернет-провайдер (ISP)</li>
<li>Система доменных имен (DNS), серверы имён, регистраторы</li>
</ol>
<p>Иногда модем и маршрутизатор - это одно и то же, но здесь они разделены для лучшего понимания темы. К концу раздела <em> вы получите понимание на высоком уровне, что происходит, когда вы набираете <a href="http://www.thediygolfer.com"" target="_blank" rel="noopener">“www.thediygolfer.com"</a> в браузере</em> . Выбран именно этот сайт, потому что он принадлежит Заку (автору данного руководства). Это позволит понять компоненты, составляющие технологии. Эти концепции сложно объяснить с помощью сложных веб-сайтов, таких как <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> потому что их инфраструктура очень сложна. Эти же концепции применимы независимо от того, какой веб-сайт вы посещаете, но будем следовать правилу "как можно проще".</p>
<p><em>Примечание: некоторые IP-адреса и адреса серверов изменены на протяжении всего руководства, чтобы защитить конфиденциальность Зака, однако указанные изменения не влияют концептуально на излагаемый материал.</em></p>
<p>Начнем с диаграммы, которая демонстрирует процесс поиска веб-сайта.</p>
<img src="/blog/2019/bash-essentials/basic-web-search.jpg">
<p>Каждый фрагмент технологии пронумерован и иллюстрирует общий поток информации при выполнении поиска в Интернете. В большинстве случаев все начинается с шага №1, тут необходимо понимать, что такое интернет-провайдер (ISP) и какие услуги он предоставляет. Сервисы интернет-провайдеров во многих случаях сбивают с толку, потому что они предлагают несколько услуг, здесь будем считать, что интернет-провайдеры предлагает только доступ Интернет в качестве услуги. Интернет-провайдер - это компания, которая владеет оборудованием и подключает к этому оборудованию клиентов, таким образом предоставляя ему интернет-услуги. О каком оборудовании мы говорим? Многие интернет-провайдеры имеют оборудование для передачи аналоговых сигналов, известных как «Интернет».</p>
<ul>
<li>Коаксиальные кабели, что сейчас уже не встречается</li>
<li>Кабели неэкранированной витой пары (UTP, 100 МГц)</li>
<li>Кабели с экранированной витой парой (STP)</li>
<li>Волоконно-оптические кабели (самый быстрый тип, много оптики лежит на дне океана)</li>
</ul>
<p>Технологии предоставляют несколько способов "доставки" Интернета в дом, но наиболее распространенным является провода UTP. Другие вариянты включают подземные кабели и спутниковые тарелки. Передача интернета "по проводам" часто сбивает людей с толку, потому что, исходя из названия, можно предположить, что только телефонные сигналы могут передаваться по телефонным проводам. Но это не наш случай Интернет ранее функционировал на инфраструктуре телефонной системы, и в настоящее время в каждом телефонном проводе орагнизовано несколько каналов связи. Это называется «широкополосным доступом», и по этой причине можно одновременно разговаривать по телефону, смотреть Netflix и искать информацию в Интернете. Раньше приходилось использовать «дозвон», когда пользователи буквально «звонили» по телефонной линии для доступа в Интернет.</p>
<p>Независимо от того, какой метод подключения к Интернету использует интернет-провайдер, всегда сталкиваеися с одной и той же проблемой. Сигналы, проходящие по телефонной линии до вашего интернет-провайдера <em>аналоговые</em>, в то время как работа компьютера соответствует <em>цифровой</em> технологии передачи сигналов (единицы и нули). Вот где используется устройство-модем.</p>
<p>Модем принимает аналоговый сигнал, преобразует его в цифровой и отправляет на маршрутизатор. Пока нам не важно, что делает маршрутизатор, но теперь есть начальная информация, необходимая для понимания диаграммы. Интернет-провайдеры владеют тоннами проводов и инфраструктурой, к которой подключаются миллионы людей, а также между провайдерами существуют соединения. Это составляет Интернет, и он поставляется в дом через телефонные провода, подземные кабели или спутник. Придостижении дома, он преобразуется в цифровые сигналы модемом и отправляется на маршрутизатор. Теперь наш вопрос: что маршрутизатор делает с сигналом?</p>
<p>Это сложный вопрос, так как теперь рассмотрим поток информации, начиная с первого звена в цепи - компьютера. Подключение к Интернету, предоставляемое провайдером, бесполезно, если оно не используется, поэтому сначала нужно сделать интернет-запрос, чтобы увидеть его в действии. Как уже упоминалось, Для выполнения поиска на главной странице сайта <a href="http://www.thediygolfer.com" target="_blank" rel="noopener">www.thediygolfer.com</a></p>
<p>Запускаем компьютер, открываем браузер (в данном случае Google Chrome) и набираем “<a href="http://www.thediygolfer.com"" target="_blank" rel="noopener">www.thediygolfer.com"</a> в строке адреса. Нажимаем ВВОД. Теперь, используя эту информацию, браузерное приложение "должно отправиться в путешествие по всемирной паутине", чтобы найти веб-сайт. Веб-сайт - это набор файлов, находящихся в серверном приложении, запущенном на каком-то компьютере где-то в мире. В нашем случае сайт, который мы ищем, находится где-то в Нью-Йорке, но наш браузер еще этого не знает!</p>
<p>Первый шаг, который предпримет компьютер, - это формирование базового HTTP-запроса GET. Не важно понимать, что это означает, но нужно понимать, что это структурированный способ взаимодействия браузера. Вот этот GET-запрос.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.thediygolfer.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br></pre></td></tr></table></figure>
<p>Не будем разбираться в каждой строке, но можно сделать разумную оценку, что означает каждая строка. Посмотрим на строку “Host: <a href="http://www.thediygolfer.com"" target="_blank" rel="noopener">www.thediygolfer.com"</a>. Эта информация вместе с остальной помещается в “packet”, который затем отправляется маршрутизатору через соединение между маршрутизатором и беспроводной картой вашего компьютера. Как только он достигнет маршрутизатора, устройство будет действовать как «сортировочная машина» и направлять запрос туда, куда нужно. Настоящий вопрос: как маршрутизатор узнает, куда должен идти этот запрос?</p>
<p>Здесь на помощь приходит система доменных имен (DNS). По всему миру тысячи серверов работают для одной цели. Эта цель - преобразовать удобочитаемые доменные имена в IP-адреса. Другими словами, маршрутизатор знает, куда направить запрос, потому что у него есть доступ к серверу доменных имен. У каждого маршрутизатора есть DNS-сервер по умолчанию, который он использует. Данный маршрутизатор использует сервер доменных имен, расположенный по адресу <code>208.67.222.123</code>. Если набрать этот IP-адрес в поисковый сайт, например <a href="https://whatismyipaddress.com/ip" target="_blank" rel="noopener">https://whatismyipaddress.com/ip</a>, можно получить следующий ответ сервера DNS.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IP:	208.67.222.123</span><br><span class="line">Decimal:	3494108795</span><br><span class="line">Hostname:	resolver1-fs.opendns.com</span><br><span class="line">ASN:	36692</span><br><span class="line">ISP:	OpenDNS, LLC</span><br><span class="line">Organization:	OpenDNS, LLC</span><br><span class="line">Services:	None detected</span><br><span class="line">Type:	Corporate</span><br><span class="line">Assignment:	Static IP</span><br><span class="line">Blacklist:	</span><br><span class="line">Continent:	North America</span><br><span class="line">Country:	United States us flag</span><br><span class="line">Latitude:	37.751  (37° 45′ 3.60″ N)</span><br><span class="line">Longitude:	-97.822  (97° 49′ 19.20″ W)</span><br></pre></td></tr></table></figure>
<p>Сразу видно, что этим сервером управляет OpenDNS LLC, это всем известный DNS-сервер. Другой хорошо известный DNS-сервер - это Google, работающий по IP-адресу 8.8.8.8.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IP:	8.8.8.8</span><br><span class="line">Decimal:	134744072</span><br><span class="line">Hostname:	google-public-dns-a.google.com</span><br><span class="line">ASN:	15169</span><br><span class="line">ISP:	Google</span><br><span class="line">Organization:	Google</span><br><span class="line">Services:	None detected</span><br><span class="line">Type:	Corporate</span><br><span class="line">Assignment:	Static IP</span><br><span class="line">Blacklist:	</span><br><span class="line">Continent:	North America</span><br><span class="line">Country:	United States us flag</span><br><span class="line">Latitude:	37.751  (37° 45′ 3.60″ N)</span><br><span class="line">Longitude:	-97.822  (97° 49′ 19.20″ W)</span><br></pre></td></tr></table></figure>
<p>Маршрутизатор свяжется со своим DNS-сервером по умолчанию, который затем выполнит поиск адреса “<a href="http://www.thediygolfer.com"" target="_blank" rel="noopener">www.thediygolfer.com"</a>. Предполагая, что он не найдет его сразу в своем кеше, он начнет искать с базы данных корневого домена для <code>.com</code>, домена верхнего уровня, размещенного на хостинге компании VeriSign. Это известно потому что <a href="https://www.iana.org/domains/root/db/com.html" target="_blank" rel="noopener">это можно узнать на IANA.org</a>. Корневой базе данных известно, где нахдится <code>thediygolfer.com</code> потому, что но зарегистрирован у официального регистратора <a href="https://www.namesilo.com/register.php?rid=21c9e40dd" target="_blank" rel="noopener">NameSilo</a>. При регистрауии домена, он был помещен в базу данных домена верхнего уровня <code>.com</code>, размещенную в Verisign. ??? Затем я сказал NameSilo, где хочу указать доменное имя. ??? Поскольку сайт размещен на DigitalOcean, NameSilo было сообщено указывать на <code>thediygolfer.com</code> его DNS-серверами DigitalOcean, а именно:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">173.245.58.51</span><br><span class="line">173.245.59.41</span><br><span class="line">198.41.222.173</span><br></pre></td></tr></table></figure>
<p>Любой из этих трех серверов будет знать, какой IP-адрес соответствует <code>thediygolfer.com</code>. На этом этапе мой маршрутизатор запустил сервер OpenDNS по умолчанию для поиска<code> thediygolfer.com</code>, но не сумев найти его, OpenDNS перенаправил маршрутизатор в базу данных корневого домена, который, затем, нашел домен и перешел на серверы имен Digital Ocean, точно знающие, где находится физический сервер сайта. Маршрутизатор рассчитает самый быстрый путь до цели и перешлет пакет запроса в соответствующем направлении.</p>
<p>С другой стороны, сервер, на котором работает веб-сайт, найдет запрошенный HTML-документ (домашняя страница), упакует его и отправит обратно на запрашивающий IP-адрес (мой компьютер). Пакеты будут доставлены на домашний маршрутизатор, но как маршрутизатор узнает, где находится компьютер? Здесь подходим к локальным сетям.  </p>
<p>Маршрутизатор представляет собой «локальную сеть» и фактически имеет динамический внешний IP-адрес (DHCP), который время от времени меняться провайдером. Это нормально, потому что отосланный запрос имеет текущий IP-адрес домашней сети, и поэтому сервер, отправляющий информацию, найдет эту сеть. Как только он находит сеть, маршрутизатор отвечает за маршрутизацию информации на нужное устройство в локальной сети.</p>
<p>В доме есть несколько устройств (ноутбук, настольный компьютер, принтер и т.д.), Поэтому для каждого устройства в домашней сети потребуется свои IP-адреса. Было бы сложно управлять новым IP-адресом для каждого устройства в "дикой природе", но с нашей локальной сетью это просто. Сеть имеет IP-адрес, который называется «шлюзом по умолчанию». Этот IP-адрес представляет все устройства в сети, через него уходит и входит трафик Интернет. Внутри локальной сети каждое устройство имеет уникальный IP-адрес в пределах адресного пространства локальной сети, заданного соответствующей маской. Эту тему невозможно понять без усвоения сетевых технологий. Для более глубокого усвоения темы есть <a href="/blog/2019/ip-addresses-netmasks">отдельный пост</a>, который предназначен тем, кому интересно. Если вы решите не тратить время на читение, вот некоторые заметки и диаграмма:</p>
<img src="/blog/2019/bash-essentials/ipaddresses.PNG">
<ul>
<li>Ваш интернет-провайдер назначает вашей сети IP-адрес и маску подсети. Их объединение дает адрес «сети» или «шлюза по умолчанию». Другими словами, IP-адрес состоит из двух частей - идентификатора сети и идентификатора «адресного пространства» сети.</li>
<li>Маски подсети используются для экономии адресного пространства, используемого одной сетью. Адресное пространство - это диапазон IP-адресов, доступных для устройств в сети (например, 192.0.168.1, 192.0.168.2, 192.0.168.3, 192.0.168.4,…, 192.0.168.254)</li>
<li>DHCP - это сервер (обычно работающий на маршрутизаторе), который назначает новому устройству IP-адрес, когда оно входит в сеть. Этот IP-адрес всегда будет в адресном пространстве, определенном маской подсети.</li>
</ul>
<p>В любом случае, вернемся к нашему обсуждению ... У нас есть несколько пакетов данных, которые приходят с сервера веб-сайта и доставляются на наш маршрутизатор. Устройство, с которого вы выполняли поиск, обнаруживается маршрутизатором, данные веб-сайта доставляются, и домашнюю страницу <a href="http://www.thediygolfer.com" target="_blank" rel="noopener">www.thediygolfer.com</a> отображается в браузере. Этт процесс происходит за секунды (или даже миллисекунды). Обладая этими базовыми знаниями, теперь можно взглянуть на некоторые команды bash, которые помогут нам диагностировать сетевые проблемы.</p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="Утилита ifconfig"></a>Утилита ifconfig</h3><p>Команда ifconfig предоставит нам информацию о домашней локальной сети, которую мы только что обсудили. Эту команду также можно использовать для установки новых настроек, но нам достаточно просто посмотреть на результат. Наберите <code>ifconfig</code> в терминале, в результате получится результат, похожий на следующий.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">enp37s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 70:85:c2:7c:ff:f2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">enx000f00de66da: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet &lt;hidden for privacy&gt;  netmask 255.255.255.0  broadcast &lt;hidden for privacy&gt;</span><br><span class="line">        inet6 &lt;hidden for privacy&gt;  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0f:00:de:66:da  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 265073  bytes 821138812 (821.1 MB)</span><br><span class="line">        RX errors 0  dropped 1451  overruns 0  frame 0</span><br><span class="line">        TX packets 44132  bytes 102041651 (102.0 MB)</span><br><span class="line">        TX errors 0  dropped 2100 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 752935  bytes 54372769 (54.3 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 752935  bytes 54372769 (54.3 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>В данной конфигурации есть три записи. Нижняя запись, относящаяся к интерфейсу «lo», представляет собой конфигурацию интерфейса обратной связи, его адрес 127.0.0.1, localhost, он обычно используется для разработки веб-приложений. Первая запись «enp37s0» кажется пустой конфигурацией. Средняя запись «enx000f00de66da» отображает IP-адрес устройства, подключенного к маршрутизатору (локальной сети), маску подсети и широковещательный адрес этой сети.  </p>
<p>Вот где <a href="/blog/2019/ip-addresses-netmasks">понимание IP-адресов и подсетей в локальной сети</a> полезно, потому что указанный адрес INET на самом деле не является общедоступным IP-адресом, распознаваемым маршрутизаторами Интернета. Этот IP-адрес является <em>локальным</em>, который нужно преобразовать во "внешний" IP-адрес сети, объединив его с маской подсети. Также указан широковещательный адрес, но он легко получается его из IP-адреса и маски подсети.</p>
<p>Если я наберу ifconfig на другом компьютере в своей сети, широковещательный адрес и маска подсети не изменятся, но IP-адрес изменится. Также есть данные, такие как максимальный размер пакета (MTU) и счетчики пакетов RX/TX, которые указывают, сколько пакетов было передано в локальную сеть и из нее. Эти значения постоянно увеличиваться.</p>
<h3 id="ping"><a href="#ping" class="headerlink" title="Программа ping"></a>Программа ping</h3><p>Программа <code>ping</code> - это базовая утилита, используемая для проверки связи между устройствами в локальной сети или даже между устройствами за пределами локальной сети. Команда полезна в случаях отсутствия браузера для проверки подключения к Интернету. У команды есть различные флаги, но единственное, что вам нужно знать сейчас, - это флаг <code>-c</code>, позволяющий указывать количество пакетов, которые мы хотим отправить серверу.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 5 thediygolfer.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PING thediygolfer.com (104.248.115.234) 56(84) bytes of data.</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=1 ttl=48 time=36.0 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=2 ttl=48 time=49.9 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=3 ttl=48 time=35.2 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=4 ttl=48 time=34.4 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=5 ttl=48 time=35.3 ms</span><br><span class="line"></span><br><span class="line">--- thediygolfer.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4005ms</span><br><span class="line">rtt min/avg/max/mdev = 34.427/38.183/49.912/5.885 ms</span><br></pre></td></tr></table></figure>
<p>Приведенная выше команда отправляет на главную страницу сайта 5 отдельных запросов, в результате получаем данные о каждом запросе. Основываясь на этих данных, получается, что наш компьютер подключен к сети и может подключиться к thediygolfer.com.</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="Программа traceroute"></a>Программа traceroute</h3><p>Команда traceroute - отличный способ понять, как компьютер находит сервер и через какие маршрутизаторы проходит запрос на <a href="http://www.thediygolfer.com" target="_blank" rel="noopener">www.thediygolfer.com</a>. Как было упомянуто ранее сервер сайта находится где-то в Нью-Йорке, и команда traceroute подтверждает это, показывая путь, по которому пакеты добираемся туда.</p>
<p>Эта команда может не быть установлена на компьютере по умолчанию, в этом случае ее нужно установить.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt install inetutils-traceroute</span><br></pre></td></tr></table></figure>
<p>На Mac доступ к функциям traceroute осуществляется при помощи Network Utility. При запуске traceroute, получаем следующий результат.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute --resolve-hostnames -q 1 -w 5 -I thediygolfer.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">traceroute to thediygolfer.com (104.248.115.234), 64 hops max</span><br><span class="line">  1   192.168.0.1 (_gateway)  53.296ms </span><br><span class="line">  2   142.254.145.21 (142.254.145.21)  10.502ms </span><br><span class="line">  3   24.164.117.37 (24.164.117.37)  15.953ms </span><br><span class="line">  4   65.189.128.164 (65.189.128.164)  11.035ms </span><br><span class="line">  5   65.29.1.87 (be14.pltsohae01r.midwest.rr.com)  18.102ms </span><br><span class="line">  6   65.29.1.28 (be25.clmkohpe01r.midwest.rr.com)  23.729ms </span><br><span class="line">  7   66.109.6.68 (bu-ether15.chctilwc00w-bcr00.tbone.rr.com)  31.967ms </span><br><span class="line">  8   66.109.5.136 (66.109.5.136)  34.155ms </span><br><span class="line">  9   66.109.5.225 (66.109.5.225)  26.993ms </span><br><span class="line"> 10   64.86.79.97 (ix-ae-27-0.tcore2.ct8-chicago.as6453.net)  25.094ms </span><br><span class="line"> 11   64.86.79.2 (if-ae-22-2.tcore1.ct8-chicago.as6453.net)  33.455ms </span><br><span class="line"> 12   216.6.81.28 (if-ae-26-2.tcore2.nto-new-york.as6453.net)  35.629ms </span><br><span class="line"> 13   66.110.96.5 (if-ae-12-2.tcore1.n75-new-york.as6453.net)  33.047ms </span><br><span class="line"> 14   66.110.96.26 (66.110.96.26)  34.565ms </span><br><span class="line"> 15   * </span><br><span class="line"> 16   * </span><br><span class="line"> 17   104.248.115.234 (104.248.115.234)  35.916ms</span><br></pre></td></tr></table></figure>
<p> В приведенной выше команде утилите traceroute указано, что необходимо преобразовать IP-адреса в их имена хостов (<code>--resolve-hostnames</code>), отправлять только один пакет на очередной маршрутизатор на пути следования пакета (<code>-q 1</code>), установить тайм-аут для каждого запроса в 5 секунд (<code>-w 5</code>) и, наконец, использовать протокол ICMP вместо UDP (<code>-I</code>). Как видите, путь начинается со шлюза компьютера, переходит на сервер Spectrum в Канзасе, подключается к серверу в Чикаго, подключается к серверам Digital Ocean в Нью-Йорке и, наконец, попадает на сервер веб-сайта в Нью-Джерси. Показанные места известны, так как ранее они были найдены автором на <a href="https://whatismyipaddress.com/ip-lookup" target="_blank" rel="noopener">этом онлайн-сервисе</a>.   </p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="Программа netstat"></a>Программа netstat</h3><p>Эта команда предоставляет информацию о различных сетевых протоколах (TCP/IP, UDP, ICMP и т.д.), используемые компьютером. Большая часть того, что эта программа выводит, выходит за рамки обсуждаемого выше, она заслуживает упоминания, так как это важный инструмент для понимания того, как компьютер общается с внешним миром. Например, можно ввести следующую команду, показывающую, что происходит в различных сетевых протоколах.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure>
<p>Результат запуска показан ниже. Обратите внимание, что вывод также брезан для краткости, и включены только протоколы IP, TCP и UDP.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ip:</span><br><span class="line">    400933 total packets received</span><br><span class="line">    0 forwarded</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    400933 incoming packets delivered</span><br><span class="line">    296285 requests sent out</span><br><span class="line">    3 outgoing packets dropped</span><br><span class="line">Tcp:</span><br><span class="line">    32175 active connections openings</span><br><span class="line">    28 passive connection openings</span><br><span class="line">    0 failed connection attempts</span><br><span class="line">    4 connection resets received</span><br><span class="line">    1 connections established</span><br><span class="line">    400885 segments received</span><br><span class="line">    300195 segments send out</span><br><span class="line">    41 segments retransmited</span><br><span class="line">    0 bad segments received.</span><br><span class="line">    7 resets sent</span><br><span class="line">Udp:</span><br><span class="line">    28 packets received</span><br><span class="line">    0 packets to unknown port received.</span><br><span class="line">    0 packet receive errors</span><br><span class="line">    43 packets sent</span><br></pre></td></tr></table></figure>
<p>Еще одно полезное приложение утилиты netstat - узнать, какие порты используют ("окрыли") процессы на компьютере. Процессы пока не обсуждались, это на будущее.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(Не все процессы могут быть идентифицированы, информация о процессах, не принадлежащих текущему пользователю</span><br><span class="line">не будут отображаться, нужно быть root-ом, чтобы увидеть их все.)</span><br><span class="line">Активные интернет-соединения (без серверов)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 zubuntu:35098           stackoverflow.com:https ESTABLISHED 26679/chrome --type</span><br></pre></td></tr></table></figure>
<p>Большая часть вывода этой команды удалена, но здесь видно, что в системе открыто окно Google Chrome (с идентификатором процесса 26679), и одна из вкладок открыта на stackoverflow.com. Локальный адрес означает, что локальный компьютер (zubuntu - полное имя для 127.0.0.1) открыл порт (сокет) с идентификатором 35098 для данной вкладки в окне Google Chrome. У каждой вкладки свой сокет.</p>
<h3 id="dig-host-whois"><a href="#dig-host-whois" class="headerlink" title="Программы dig/host/whois"></a>Программы dig/host/whois</h3><p>Программы <code>dig</code>, <code>host</code> и <code>whois</code> помогают узнавать информацию о доменных именах, IP-адресах и механизмах отобрахения одних в другие. Как правило, пргограммы <code>dig</code> и <code>host</code> устанавливаются на компьютер по умолчанию, а вот команду <code>whois</code>, вероятно, придется установить самостоятельно. В Linux она устанавливается путем выполнения <code>sudo apt-get install whois</code> в терминале.</p>
<p>Начнем с программы <code>dig</code>, которая помогает запрашивать записи DNS для IP-адресов (с использованием обратного поиска) или доменного имени. Используя эту утилиту, можно запросить знакомый нам сайт.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig thediygolfer.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.15-Ubuntu &lt;&lt;&gt;&gt; thediygolfer.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 51716</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;thediygolfer.com.              IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">thediygolfer.com.       600     IN      A       104.248.115.234</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 172.17.0.1#53(172.17.0.1)</span><br><span class="line">;; WHEN: Wed Feb 27 18:41:22 UTC 2019</span><br><span class="line">;; MSG SIZE  rcvd: 61</span><br></pre></td></tr></table></figure>
<p>Обратите внимание, что здесь много информации, и по большей части это комментарии (обозначены ;;). Чтобы сократить результат, можно добавить флаги <code>+noall</code> и <code>+answer</code>, т.е. показывать только раздел ответов. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig thediygolfer.com +noall +answer</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.15-Ubuntu &lt;&lt;&gt;&gt; thediygolfer.com +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">thediygolfer.com.       600     IN      A       104.248.115.234</span><br></pre></td></tr></table></figure>
<p>В результате просто будет напечатана запись A для сайта в коротком формате. Можно также запустить <code>dig thediygolfer.com +short</code>, при этом будет получен аналогичный результат. Но что, если нужны все записи DNS для домена? Для этого можно добавить опцию <code>ANY</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig thediygolfer.com ANY +noall +answer</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.15-Ubuntu &lt;&lt;&gt;&gt; thediygolfer.com ANY +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">thediygolfer.com.       3599    IN      A       104.248.115.234</span><br><span class="line">thediygolfer.com.       1799    IN      NS      ns1.digitalocean.com.</span><br><span class="line">thediygolfer.com.       1799    IN      NS      ns2.digitalocean.com.</span><br><span class="line">thediygolfer.com.       1799    IN      NS      ns3.digitalocean.com.</span><br><span class="line">thediygolfer.com.       1799    IN      SOA     ns1.digitalocean.com. hostmaster.thediygolfer.com. 1545305910 10800 3600 604800 1800</span><br></pre></td></tr></table></figure>
<p>В ответе видно, что домен содержит одну запись A (сопоставление IP-адреса и имени домена), три записи сервера имен и одна запись «Start of authority» (SOA), указывающая, что Digital Ocean является авторитетным источником для записи DNS.</p>
<p>Введем следующую команду, найдем IP-адрес домена.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">host thediygolfer.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># thediygolfer.com has address 104.248.115.234</span></span><br></pre></td></tr></table></figure>
<p>Если использовать команду с серверами Google, можно получить больше записей, так как в их сети размещено много серверов, в том числе, поддерживающих электронную почту.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host google.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">google.com has address 108.177.112.139</span><br><span class="line">google.com has address 108.177.112.101</span><br><span class="line">google.com has address 108.177.112.102</span><br><span class="line">google.com has address 108.177.112.100</span><br><span class="line">google.com has address 108.177.112.113</span><br><span class="line">google.com has address 108.177.112.138</span><br><span class="line">google.com has IPv6 address 2607:f8b0:4001:c12::64</span><br><span class="line">google.com mail is handled by 30 alt2.aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 50 alt4.aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 40 alt3.aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 10 aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 20 alt1.aspmx.l.google.com.</span><br></pre></td></tr></table></figure>
<p>Наконец, команда <code>whois</code> двет дополнительную информацию о данном доменном имени или IP-адресе. Она наверняка не установлена по умолчанию, поэтому выполнив <code>sudo apt-get install whois</code>, можно установить ее. Вот пример того, как она работает.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois thediygolfer</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Domain Name: THEDIYGOLFER.COM</span><br><span class="line">Registry Domain ID: 1896554473_DOMAIN_COM-VRSN</span><br><span class="line">Registrar WHOIS Server: whois.namesilo.com</span><br><span class="line">Registrar URL: http://www.namesilo.com</span><br><span class="line">Updated Date: 2018-12-15T15:30:57Z</span><br><span class="line">Creation Date: 2015-01-18T02:22:03Z</span><br><span class="line">Registry Expiry Date: 2020-01-18T02:22:03Z</span><br><span class="line">Registrar: NameSilo, LLC</span><br><span class="line">Registrar IANA ID: 1479</span><br><span class="line">Registrar Abuse Contact Email: abuse@namesilo.com</span><br><span class="line">Registrar Abuse Contact Phone: +1.4805240066</span><br><span class="line">Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited</span><br><span class="line">Name Server: NS1.DIGITALOCEAN.COM</span><br><span class="line">Name Server: NS2.DIGITALOCEAN.COM</span><br><span class="line">Name Server: NS3.DIGITALOCEAN.COM</span><br><span class="line">DNSSEC: unsigned</span><br><span class="line">URL of the ICANN Whois Inaccuracy Complaint Form: https://www.icann.org/wicf/</span><br></pre></td></tr></table></figure>
<p>Получена информация о заданном доменном имени.</p>
<p>Существуют и другие инструменты bash, например, <code>nslookup</code>, <code>route</code> и т.д., но которые были рассмотренв, удовлетворят большинству потребностей пользователей. Если вы не собираетесь быть администратором, настраивающим сети каждый божий день, вам никогда не понадобится использовать эти инструменты для редактирования настроек. Но эти команды также полезны для получения информации о вашей сети и о внешних сетях.</p>
<h2 id="Process-Management-and-System-Management"><a href="#Process-Management-and-System-Management" class="headerlink" title="Управление процессами и системой"></a>Управление процессами и системой</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/lfN2RE8720E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Управление процессами и системой звучит как-то пугающе. Для обычного пользователя bash существует несколько полезных команд и программ, которые надо изучить, чтобы получить целостное представление о том, как работает компьютер.</p>
<ul>
<li>Что такое процесс?</li>
<li>Как создается процесс?</li>
<li>Как управлять процессами с помощью команд kill, bg и fg</li>
<li>Как управлять процессами и контролировать системные ресурсы с помощью команды top</li>
</ul>
<h3 id="What-is-a-Process"><a href="#What-is-a-Process" class="headerlink" title="Что такое процесс?"></a>Что такое процесс?</h3><p>Если не вдаваться в технические подробности, процесс - это что-нибудь на исполняющееся на компьютере, который принадлежит пользователю и потребляет три вида ресурсов системы.</p>
<ol>
<li>Вычислительные (CPU)</li>
<li>Оперативная память (RAM)</li>
<li>Периферийные устроства ввода/вывода (input/output,IO)</li>
</ol>
<p>После загрузки компьютера ядро операционной системы функционирует постоянно. Ядро постоянно отслеживает состояние всех процессов на компьютере и выделяет им периодически те или иные системные ресурсы Процессы конкурируют за системные ресурсы, вытесняя друг друга. Верьте или нет, при запуске программы, например, Google Chrome, ядро даст ему ресурсы в течение нескольких микросекунд, а затем произойдет "переключение контекстов", и эти же ресурсы будут на время отданы другому процессу. Если Google Chrome завхватит 100% ресурсов во все 100% времени, компьютер, вероятно, выкинит Google из пямяти компьютера потому, что в ядре есть разные фцнкции поддеривающих функционирование операционной системы.</p>
<h3 id="Processes-Behind-the-Scenes"><a href="#Processes-Behind-the-Scenes" class="headerlink" title="Закулисы процессов"></a>Закулисы процессов</h3><p>Можно перечислять все возможные команды, но в этом нет особого смысла, если не понимать последовательность функций, которые выполняет bash и ядро операционной системы при создании нового процесса. Когда компьютер запускается, ядро запускает процесс под названием "init", который в UNIX-системах обычно называется также <code>init</code>, расположенный в <code>/sbin/init</code>. В современных дистрибутивах этот скрипт находится в пакете <a href="https://en.wikipedia.org/wiki/Systemd" target="_blank" rel="noopener">systemd</a>. Как только вы изучите процедуру загрузки системы, вы поймете, что происходит за кулисами на компьютере. Каждый процесс может начать другой процесс (обычно терминал начинает новый процесс в результате введенной команды), сначала создавая свою копию, а затем выполняя новую команду в адресном пространстве скопированного процесса. Вот иллюстрация, поясняющая вышесказанное: </p>
<img src="/blog/2019/bash-essentials/processes-linux.png">
<p>Можно отследить этот процесс в терминале самостоятельно, используя <code>strace()</code> команду. Обратите внимание - эта команда доступна только на Linux. Эквивалентная команда на Mac - <code>dtruss</code>, но она работает по-другому.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace ls</span><br></pre></td></tr></table></figure>
<p>Эта команда позволяет увидеть все системные вызовы, которые были выполнены при запуске <code>ls</code>. Команда <code>ls</code> на самом деле - это просто еще один процесс операционной системы. Результат работы <code>strace ls</code>, представленный ниже, обработан, так, чтобы обращать внимание читателяна наиболее важные части.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">execve("/bin/ls", ["ls"], [/* 69 vars */]) = 0</span><br><span class="line"></span><br><span class="line">.... пропущено для краткости ....</span><br><span class="line"></span><br><span class="line">write(1, "_config.yml  awk-example.sh  db."..., 107_config.yml  awk-example.sh  db.json      node_modules    package.json  scaffolds  test-permission  yarn.lock</span><br><span class="line">) = 107</span><br><span class="line">write(1, "aapl.csv     data-file.txt   lar"..., 91aapl.csv     data-file.txt   large-data.csv  package-lock.json public       source    themes</span><br><span class="line">) = 91</span><br><span class="line">close(1)                                = 0</span><br><span class="line">munmap(0x7f1578100000, 4096)            = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ завершается скодом 0 +++</span><br></pre></td></tr></table></figure>
<p>Если вам действительно интересно узнать о каждом из системных вызовов в выводе команды <code>strace</code>, <a href="https://stackoverflow.com/a/6334557" target="_blank" rel="noopener">вот отличный пост на StackOverflow</a>. Программисты на языке C, вероятно, знакомы с некоторыми из этих команд.  </p>
<p>В приведенном тексте показано, сто команда <code>execve</code>запускает процесс. Фактически, это fork и exec одновременно. Далее можно будет посмотреть, как разделять файлы и каталоги. Файлы представляют собой результат выполнения команды <code>ls</code> в текущем каталоге моей машины.  </p>
<p>В конце концов, вывод не важен пользователю bash, но важен для понимания процедуры запуска и заверения процессы. Важнее уметь <em> правлять</em> процессами. Здесь есть несколько команд, позволяющих ??? позаботятся практически обо всем, что нам когда-либо понадобится в отношении процессов.</p>
<h3 id="Foreground-vs-Background-Processes"><a href="#Foreground-vs-Background-Processes" class="headerlink" title="Процессы переднего плана и фоновые процессы"></a>Процессы переднего плана и фоновые процессы</h3><p>Одной из наиболее важных концепций, которую нужно понимать в отношении процессов, является фоновый режим процесса и "переднмй план" и как переключаться между ними. После запуска процесса в оболочке bash и пока процесс исполняется, доступа к терминалу не будет. Если надо остановить процесс используйте комбинацию клавиш CTRL-C. Есть процессы, которые выполняются всегда, и где они работают? Почему они не мешают работать в терминале? Причина в том, что они являются <em>фоновыми процессами.</em> Можем перевести процесс в фоновый режим одним из двух способов:</p>
<ol>
<li>Отправить его в фоновый режим в момент запуска</li>
<li>Остановить его и отправить в фоновый режим и дать команду продолжения исполнения</li>
</ol>
<p>Первый способ прост. Процесс будет запущен в фоновом режиме если добавить <code>&amp;</code> в конце команды. Например, можно запустить команду <code>sleep</code>, которая будет 20 секунд простаивать в фоновом режиме.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 20 &amp;</span><br></pre></td></tr></table></figure>
<p>Второй метод немного сложнее и требует от понимания концепции <em>сигналов, передаваемых процессам</em>. Посылка сигналов процессам осуществляется командой <code>kill</code>. Перечень всех сигналов выводится в результате команды <code>kill -l</code>. Вот наиболее распространенные сигналы, часто отправляемые в процесс:</p>
<ul>
<li>SIGTERM - <code>kill</code> (мягкий сигнал завершения процесса)</li>
<li>SIGKILL - <code>kill -9</code> or <code>kill -s SIGKILL</code> (силовой метод остановки процесса)</li>
<li>SIGSTOP - <code>kill -19</code> or <code>kill -s SIGSTOP</code> ([при]остановка выполнения процесса)</li>
<li>SIGCONT - <code>kill -18</code> or <code>kill -s SIGCONT</code> (продолжить выполнение процесса)</li>
<li>SIGINT (CTRL-C) - <code>kill -2</code> or <code>kill -s SIGINT</code> (Прервать выполнение процесса)</li>
<li>SIGTSTP (CTRL-Z) - <code>kill -20</code> or <code>kill -s SIGTSTP</code> ([при]остановка выполняющегося процесса)</li>
</ul>
<p>В нашем примере отправим сигнал SIGTSTP запущенному процессу, чтобы он перешел в фоновый режим и остановился. Для этого нам понадобится идентификатор процесса. Чтобы получить этот идентификатор, надо запустить команду <code>ps</code> (подробнее об этом позже). В данном случае используем <code>google-chrome</code> с нашим окном браузера, в качестве примера процесса. Идентификатор процесса - 21124, полученный в результате выполнения команды <code>ps a</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1201 tty7     Ssl+   1:48 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolis</span><br><span class="line"> 1204 tty1     Ss+    0:00 /sbin/agetty -o -p -- \u --noclear tty1 linux</span><br><span class="line">17824 pts/0    Ss     0:00 -bash</span><br><span class="line">18747 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line">19664 pts/2    Ss+    0:00 -bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Вот процесс Google Chrome (этот комментарий был вручную добавлен в текст ответа команды ps)</span></span><br>&lt;/br16&gt;<span class="line">21124 pts/2    SLl    0:03 /opt/google/chrome/chrome</span><br><span class="line"></span><br><span class="line">21129 pts/2    S      0:00 cat</span><br><span class="line">21130 pts/2    S      0:00 cat</span><br><span class="line">21133 pts/2    S      0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=zygote --<span class="built_in">enable</span>-crash-reporter=2475ab0f-df4d</span><br><span class="line">21134 pts/2    S      0:00 /opt/google/chrome/nacl_helper</span><br><span class="line">21137 pts/2    S      0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=zygote --<span class="built_in">enable</span>-crash-reporter=2475ab0f-df4d</span><br><span class="line">21164 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=gpu-process --field-trial-handle=39017447716</span><br><span class="line">21169 pts/2    SLl    0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=utility --field-trial-handle=390174477165224</span><br><span class="line">21309 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21360 pts/2    Sl     0:01 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21398 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21417 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21711 pts/2    Sl     0:01 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21751 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21852 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21870 pts/0    R+     0:00 ps a</span><br></pre></td></tr></table></figure>
<p>На самом деле есть несколько вариантов остановить выполнябщийся процесс Google Chrome. Можно послать сигнал <code>SIGTSTP</code> (т.е. CTRL-Z) или сигнал <code>SIGSTOP</code> процессу. Любой из них остановит запущенный процесс и вернет нам доступ к терминалу. Отправим процессу сигнал <code>SIGSTOP</code> из другого терминального окна.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGSTOP 21124</span><br><span class="line"><span class="comment"># `kill -19 21124` также работает</span></span><br></pre></td></tr></table></figure>
<p>Заметим, когда вы пытаетесь сделать что-либо в окне Chrome, он не работает, потому что он - приостановленный процесс. Теперь можно снова запустить процесс, но на этот раз запустим его в фоновом режиме. Для этого перейдите в терминал, на котором находится остановленный Google Chrome, и введите команду <code>jobs</code>. В результате получите список заданий для данного терминала. Найдем номер, по которому идентифицируем Google Chrome (в данном случае - задание №1), выполним команду.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> %1</span><br></pre></td></tr></table></figure>
<p>Google Chrome теперь перезапущен и работает в фоновом режиме. Снова остановим его и вернем на передний план.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Останавливает процесс</span></span><br><span class="line"><span class="built_in">kill</span> -s SIGSTOP 211124</span><br><span class="line"></span><br><span class="line"><span class="comment"># Запускает процесс</span></span><br><span class="line"><span class="built_in">kill</span> -s SIGCONT 211124</span><br><span class="line"></span><br><span class="line"><span class="comment"># Перевод процесса в фоновый режим</span></span><br><span class="line"><span class="built_in">fg</span> %1</span><br></pre></td></tr></table></figure>
<h3 id="ps-and-top-commands-system-performance-management"><a href="#ps-and-top-commands-system-performance-management" class="headerlink" title="Команды ps и top (управление общей производительностью системы)"></a>Команды ps и top (управление общей производительностью системы)</h3><p>Есть две команды, показывающие процессы, выполняемые в настоящее время на нашем компьютере. В 99% случаев эти команды взаимозаменяемы. Разница между командами заключается в уровне интерактивности, опыт показывает, что используются они часто и обе. Например, при запускае <code>top</code> получаем список процессов. Этот список не просто выдается, но и отслеживает статус каждого процесса в реальном времени. Поскольку top интерактивен, другие сценарии не могут использовать его для получения информации о процессах без специальных настроек (т.е. с использованием «пакетного» режима). Вот где пригодится команда <code>ps</code>. Команда используется внутри скриптов bash для получения необходимой информации. Поскольку мы не собираемся разрабатывать сложные скрипты использования процессов, первую очередь упор сделаем на <code>top</code>, поскольку она является более удобной для пользователя. Можно изучить страницы руководства man для команды <code>ps</code>, где перечисляются эквивалентные команды тем, о которых далее идет речь, например, <code>ps ax</code> распечатывает все ваши текущие процессы.</p>
<p>Приоритетом в изучении здесь является интерфейс команды <code>top</code> и что нужно искать на экране. Программа top - это не просто команда bash, она имеет свои собственные обширные возможности. Обычные пользователи bash не используют большинство этих возможностей, приведем самые полезные.</p>
<img src="/blog/2019/bash-essentials/top-header.png">
<p>При первом запуске программы top, экран заполнится информацией, как на рисунке. Экран включает пять строк, начиная с верхней строки (1) и заканчивая нижней строкой (5), разберем, какую информацию они отображают.</p>
<ol>
<li>Общая информация</li>
<li>Показывает различные типы задач, выполняемые на компьютере. Задачи могут находиться в состоянии running (выполняется), stopped (остановлен), sleeping (простой) или zombie (зомби). Суть их интуитивно понятна, за исключением процессов в состоянии зомби. Такие процессы является всего лишь процессами, которые погибают, но все еще перечислены в таблице процессов, как правило, потому, что родительский процесс не смог вычистить его ресуры.</li>
<li>Статистика времени использования процессора, включая us (время пользователя, un-niced), sy (время системы), ni (время пользователя, niced), id (время холостого хода), и wa (время ожидания В-В). Столбцы hi, si, и st нам не важны. Можно вычислить общее время пользователя (время, необходимое для запуска непосредственно кода программы) - сумма us и ni. Данные этой строки будут полезны когда будем отфильтровать процессы.</li>
<li>Cтатистика использования оперативной памяти. В режиме отображения всех процессов при недостатке свободная памяти может отображаться красный флаг, сигнализирующий, что память заканчивается.</li>
<li>Статистика памяти swap (подкачки). Подкачка используется только тогда, когда реальная память исчерпана, так низкие цифры в "свободной" части <em>реальной памяти</em> и высокие цифры в "использованной" части <em>своп</em> - признак возникновения проблемы производительности системы, что, как правило, вызвано слишком малым размером оперативной памяти.</li>
</ol>
<p>Наблюдая за текстом, выдаваемом командой top, можно заметить, что он обновляется каждые несколько секунд. Таким образм мы получаем информацию о состоянии компьютера в реальном времени. Интервалом обновления также можно управлять. Интервал настраивается двумя способами - «статическим» и «интерактивным». В статическом режиме конфигурация программы top устанавливается в командной строке. Например, можно запустить программу top так: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 10</span><br></pre></td></tr></table></figure>
<p>При этом в top будет установлен интервал 10 секунд. Значение интервала настраивается нажатием клавиши <code>d</code> вводом длины интервала в секундах. Откуда можyj узнать, как управлять программной top? С одной стороны, это чтение подсказок man, но есть и другой способ - ввод символа <code>?</code> в запущенной программе top. В результате будет показана страница справки, направляющая пользователя по функциям программы. На этом экране находится только информация об «интерактивном» режиме, показанный текст - это все, что вам когда-либо понадобится. В отличие от команды <code>ps</code>, top не требует повторного ввода в командной строке <code>top</code> с новыми флагами потому, что все настройки делаются в самой программе.</p>
<p>Программа top очень удобна как инструмент управления и процессами и системой. Продолжая нашу дискуссию по управлению процессами, покажем как "убить" процессы в программе top. Делается это нажатием клавиши <code>k</code> и указанием номера процесса. По умолчанию процессу будет послан сигнал <code>SIGINT</code>. Программа не позволяет указывать, какой сигнал требуется послать, но это быстрый способ убить процесс, не покидая программу top.</p>
<p>Также можно фильтровать процессы по идентификатору процесса и по идентификатору пользователя. Оба фильтра можно установить на командной строке при запуске программы.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Показывает процессы пользователя "zach"</span></span><br><span class="line">top -u zach</span><br><span class="line"></span><br><span class="line"><span class="comment"># Показывает процесс с номером 22435</span></span><br><span class="line">top -p 22435</span><br></pre></td></tr></table></figure>
<p>Можно выполнять фильтрацию в интерактивном режиме программы top. Если надо показать только процессы пользователя <code>zach</code>, нажимаем клавмшу <code>n</code>, вводим "zach". Если надо показать только процесс по ID <code>22435</code>, надо задать фильтр. Делается это так: </p>
<ol>
<li>Нажмите букву <code>O</code> (верхний регистр) в интерактивном режиме</li>
<li>Надо набрать <code>PID=22435</code> и нажать Enter</li>
<li>Проверка фильтров осуществляется CTRL-o (control + клавиша o)</li>
<li>Очистить фильтры можно нажав <code>=</code></li>
</ol>
<p>По умолчанию, top выдает много данных, и иногда надо будет прокрутить список. Можно прокручивать текст, выдаваемый программой, с помощью клавиш вверх, вниз, влево и вправо. Чтобы сориентироваться в тексте, введите <code>C</code>. В результате в верхней части экрана будет показано что-то вроде <code>scroll coordinates: y = 13/345 (tasks), x = 1/12 (fields)</code>.</p>
<p>Можно изменять, какие поля отображаются, введя букву <code>f</code> в интерактивном режиме. Как только нажмета на эту букву, будет показана куча различных вариантов отображения данных. Прежде чем научиться указывать поля, надо перечислить имена полей по умолчанию, показать что они означают.</p>
<ol>
<li>PID - Идентификатор процесса</li>
<li>USER - Идентификатор пользователя, владеющего процессом</li>
<li>PR - Приоритет, согласно которому выполняется процесс (значение <code>rt</code> обозначает, что процесс выполняется в реальном времени)</li>
<li>NI - Значение “Nice” процесса. Реальный приоритет пользовательского процесса состоит из приоритета (PR), вычисляемый по формуле PR = 20 + NI. Для PR и NI работает общее правило: чем меньше число, тем выше приоритет. Посмотрите <a href="https://askubuntu.com/a/656787/917201" target="_blank" rel="noopener">публикацию</a>, где приводится более детальное объяснение сути приоритетов.</li>
<li>VIRT - Размер всей вирткальной памяти, занимаемой процессом</li>
<li>RES - часть VIRT, расположенная конкретно в ОЗУ</li>
<li>SHR - часть RES, разделяемая память</li>
<li>S - состояние процесса: S-спячка (sleep), R-активен (running), I-простой (idle)</li>
<li>%CPU - Доля использования процессора данным процессом с момента последнего обновления экрана. Например, если %CPU=50, а интервал обновления составляет 10 секунд, это значит, что за последние 10 секунд, процесс пользовался 50% рабочего времени процессора, т.е. 5 секунд.</li>
<li>%MEM - То же, что и RES, но выражено в процентах</li>
<li>TIME+ - Общее время вычислений процесса с момаента его запуска в предположении, что вблучем "накопительный" режим, который переключается при помощи <code>S</code>)</li>
<li>COMMAND - Команда, стартовавшая процесс. Нажатие <code>c</code> меняет режим отображения между полным наименованием и его сокращенным вариантом.</li>
</ol>
<p>Мастера управления системой могут извлечь больше полезной информации из значений других полей. Чтобы изменить перечень полей, надо нажать <code>f</code>, что откроет менеджер отображаемых полей. Здесь можно просматривать информацию, пролистывая список вверх и вниз стрелками, так можно найти нужное поле. Если против поля виднеется <code>*</code>, то это значит, что данное поле сейчас отображается. Переключение режима отображения осуществляется буквой <code>d</code>. Чтобы переместить команду на новое место в меню надо ее выделить при помощи клавиши "вправо", далее, при помощи стрелок "вверх" и "вниз" производится размещение поля по вашему желанию. В конце нажатием стрелки "влево" фиксируется позиция. Можно менять режим сортировки (поле по которому осуществляется сортировка) в главном экране, выделив поле и нажав клавишу <code>s</code>. Нажатие <code>q</code> для выхода из программы. После того как настройка top будет закончена, можно выйти из экрана настройки полей и нажмите клавишу <code>W</code> чтобы сохранить настройки в файле <code>~/.toprc</code></p>
<p>Если вы хотите отобразить несколько окон, что top тоже позволяет, можно активировать альтернативный режим отображения, вводя <code>A</code>. Оказавшись в этом режиме, можно использовать клавиши <code>a</code> и <code>w</code> для перемещения между четырьмя окнами (вы увидите факт обновления окна в левом верхнем углу страницы) и <code>G</code> для переименования текущее окна. Удобство заключается в возможности видеть четыре окна, которые все настроены на определенные варианты просмотра процессов.</p>
<p>Что же нам дает использование команды top? Она решает всего нескольких задач: </p>
<ol>
<li>Сводная страница - получение обобщенной статистики о работе компьютера</li>
<li>%CPU - поиск процессов, "съедающий" все вычислительные ресурсы вашего процессора.</li>
<li>%MEM - поиск процессов, "съедающих" все ресурсы оперативной памяти. Статичтика столбца %MEM включает <code>RES</code>, отражающий резидентную часть, или, другими словами, сколько процесс реальнно использует именно оперативную память. VIRT = RES + SWAP, поэтому если VIRT намного больше, чем RES, это означает, что процесс активно использует SWAP, а это означает, что в оперативной памяти компьютера не хватает места для процесса.</li>
</ol>
<p>Команда top отлично подходит для получения общего обзора состояния компьютера, касающихся использования его ресурсов, но есть еще несколько команд, которые дают более полное представление о том, как работает компьютер.</p>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="Программ lsof"></a>Программ lsof</h3><p>Команда lsof используется для вывода списка открытых процессом файлов. На первый взгляд это не так уж интересно, но, поскольку в операционных системах на базе UNIX все объекты представляются в виде файлов, этот инструмент позволяет видеть больше, чем просто открытые процессом файлы. Есть много способов использования этого инструмента, но вот пара вариантов, которые в какой-то момент могут пригодиться любому пользователю bash.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Список всех файлов, которые открыл пользователь zach</span></span><br><span class="line">lsof -u zach</span><br><span class="line"></span><br><span class="line"><span class="comment"># Список всех сетевых подключений</span></span><br><span class="line">lsof -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># Список всех процессов, осуществляющих сервис на порту 22</span></span><br><span class="line">lsof -i TCP:22</span><br><span class="line"></span><br><span class="line"><span class="comment"># Список всех файлов, открытых на моем внешнем жестком диске</span></span><br><span class="line"><span class="comment"># комбинация "+f --" означает, что остаток команды (после "--") - это точка монтирования</span></span><br><span class="line">lsof +f -- /media/my_hard_drive</span><br></pre></td></tr></table></figure>
<h3 id="free-time"><a href="#free-time" class="headerlink" title="Команды free и time"></a>Команды free и time</h3><p>Команда free - это быстрый способ оценки ресурсы вашей системы в заданный момент. Добавление ключа <code>--мега</code> к команде позволяет отображать объем оперативной памяти в мегабайтах, а не как по умолчанию в кибибайтах.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free --mega</span><br></pre></td></tr></table></figure>
<p>Также есть команда под названием <code>time</code>, показывающая сколько процессорного времени занимает выполнение конкретной программы. Например, выполним следующую команду: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time google-chrome</span><br><span class="line"></span><br><span class="line"><span class="comment"># Результат</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># real	0m0.458s</span></span><br><span class="line"><span class="comment"># user	0m0.229s</span></span><br><span class="line"><span class="comment"># sys	0m0.063s</span></span><br></pre></td></tr></table></figure>
<p>Это запустит<code> Гугл Хром</code> исполняемый файл (открывает окно Google Chrome) и отслеживает, сколько реального, пользовательского и системного времени было использовано для этого исполняемого файла. Реальное (real) время - это общее время, затраченное на выполнение программы. Пользовательское (user) время - это время, необходимое для исполнения кода программы, а системное (system) время - это время, в течение которого ядро использовало системные ресурсы для обеспечения сервиса браузеру. Следующая формула показывает, сколько времени процесс простаивал из-за отсутствия доступа к ресурсам.</p>
<p>Время ожидания = Real - User - System</p>
<p>Трудно определить точное время ожидания без специального тестирования производительности, но для грубой оценки wait вполне подходит.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Заключение"></a>Заключение</h2><p>Трудно в это поверить, но данный пост автор таки закончил. К данному моменту у вас должен сформироваться набор навыков среднего - продвинутого уровня использования оболочки bash, вы должны быть в курсе того, что такое <a href="/blog/2019/user-permissions/">users, groups, и permissions</a>. Надеюсь, что у вас рано илии позно будет высокий уровень понимания bash и даже Linux.</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="http://zachgoll.github.io">Домашняя страница</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="http://zachgoll.github.io/portfolio">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Environment-variables"><span class="toc-number">1.</span> <span class="toc-text">Переменные среды</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Variables"><span class="toc-number">1.1.</span> <span class="toc-text">Переменные оболочки</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PATH-variable"><span class="toc-number">1.2.</span> <span class="toc-text">Переменная PATH</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Common-Commands"><span class="toc-number">1.3.</span> <span class="toc-text">Общие команды</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">1.3.1.</span> <span class="toc-text">grep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk-and-sed"><span class="toc-number">1.3.2.</span> <span class="toc-text">awk и sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Less"><span class="toc-number">1.3.3.</span> <span class="toc-text">Less</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-and-exec"><span class="toc-number">1.3.4.</span> <span class="toc-text">find и exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar-gzip-gunzip"><span class="toc-number">1.3.5.</span> <span class="toc-text">tar, gzip, gunzip</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Advanced-Bash"><span class="toc-number">2.</span> <span class="toc-text">дополнительные возмодности Баш</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Regular-Expressions"><span class="toc-number">2.1.</span> <span class="toc-text">Обычные выражения</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Detailed-Example-Regular-Expression"><span class="toc-number">2.1.1.</span> <span class="toc-text">Подробный пример регулярных выражений</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-Scripting"><span class="toc-number">2.2.</span> <span class="toc-text">Сценарии Bash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Variable-declarations"><span class="toc-number">2.2.1.</span> <span class="toc-text">Объявления переменных</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Built-In-Variables"><span class="toc-number">2.2.2.</span> <span class="toc-text">Встроенные переменные</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-Line-Arguments"><span class="toc-number">2.2.3.</span> <span class="toc-text">Аргументы командной строки</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reading-user-input"><span class="toc-number">2.2.4.</span> <span class="toc-text">Чтение ввода с клавиатуры</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-loops"><span class="toc-number">2.2.5.</span> <span class="toc-text">циклы for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-then-statements"><span class="toc-number">2.2.6.</span> <span class="toc-text">операторы if-then</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions"><span class="toc-number">2.2.7.</span> <span class="toc-text">Функции</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-Machines-and-SSH-Protocol"><span class="toc-number">2.3.</span> <span class="toc-text">Виртуальные машины и протокол SSH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Permanently-Add-Keys-to-ssh-agent"><span class="toc-number">2.3.1.</span> <span class="toc-text">Permanently Add Keys to ssh-agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-local-computer-to-remote-machine"><span class="toc-number">2.3.2.</span> <span class="toc-text">С локального компьютера на удаленный</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-remote-machine-to-local-computer"><span class="toc-number">2.3.3.</span> <span class="toc-text">С удаленного компьютера на локальный</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Downloading-packages-to-your-remote-machine-with-wget"><span class="toc-number">2.3.4.</span> <span class="toc-text">Загрузка пакетов на удаленный компьютер при помощи wget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-VSCode-with-your-remote-machine"><span class="toc-number">2.3.5.</span> <span class="toc-text">Использование VSCode на удаленной машине</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Networking-on-Command-Line"><span class="toc-number">2.4.</span> <span class="toc-text">Работа в сети в командной строке</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Your-home-network-and-the-internet"><span class="toc-number">2.4.1.</span> <span class="toc-text">Ваша домашняя сеть и Интернет</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifconfig"><span class="toc-number">2.4.2.</span> <span class="toc-text">ifconfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping"><span class="toc-number">2.4.3.</span> <span class="toc-text">ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#traceroute"><span class="toc-number">2.4.4.</span> <span class="toc-text">traceroute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat"><span class="toc-number">2.4.5.</span> <span class="toc-text">netstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dig-host-whois"><span class="toc-number">2.4.6.</span> <span class="toc-text">dig/host/whois</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Process-Management-and-System-Management"><span class="toc-number">2.5.</span><span class="toc-text">Управление процессами и управление системой</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-Process"><span class="toc-number">2.5.1.</span> <span class="toc-text">Что такое процесс?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processes-Behind-the-Scenes"><span class="toc-number">2.5.2.</span> <span class="toc-text">Процессы: что за кулисами</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foreground-vs-Background-Processes"><span class="toc-number">2.5.3.</span> <span class="toc-text">Процессы на переднем плане и фоновые процессы</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ps-and-top-commands-system-performance-management"><span class="toc-number">2.5.4.</span> <span class="toc-text">команды ps и top (управление производительностью системы)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsof"><span class="toc-number">2.5.5.</span> <span class="toc-text">lsof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-time"><span class="toc-number">2.5.6.</span> <span class="toc-text">free, time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">2.6.</span> <span class="toc-text">Заключение</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;text=Bash Essentials"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;is_video=false&amp;description=Bash Essentials"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Bash Essentials&amp;body=Check out this article: http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;title=Bash Essentials"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://zachgoll.github.io/blog/2019/bash-essentials/&amp;name=Bash Essentials&amp;description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Меню</a> <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> Содержание</a> <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Поделиться</a> <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> В начало</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright © 2019 Зак Голлвитцер
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="http://zachgoll.github.io">Домашняя страница</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="http://zachgoll.github.io/portfolio">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/blog/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/blog/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/blog/lib/jquery/jquery.min.js"></script>
<script src="/blog/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/blog/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-149577498-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'zachgoll';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


